{"meta":{"title":"缥缈孤鸿影","subtitle":null,"description":null,"author":"SilentZhou","url":"https://www.blocknews.xyz"},"pages":[],"posts":[{"title":"hello hexo","slug":"hello-hexo","date":"2019-01-23T07:03:32.000Z","updated":"2019-01-23T07:05:46.392Z","comments":true,"path":"2019/01/23/hello-hexo/","link":"","permalink":"https://www.blocknews.xyz/2019/01/23/hello-hexo/","excerpt":"","text":"Hello Hexo##What is Hexo? Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.","categories":[],"tags":[]},{"title":"[译]什么是纯函数?","slug":"译-什么是纯函数","date":"2019-01-23T01:56:37.000Z","updated":"2019-01-23T07:13:05.085Z","comments":true,"path":"2019/01/23/译-什么是纯函数/","link":"","permalink":"https://www.blocknews.xyz/2019/01/23/译-什么是纯函数/","excerpt":"","text":"原文链接： Master the JavaScript Interview: What is a Pure Function?原文作者：Eric Elliott译者：SilentZhou 纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？ 通过一个免费课程 “Learn JavaScript with Eric Elliott”:我们能够回答这个问题。 在我们掌握什么是纯函数之前,让我们先仔细看看什么是函数。或许有一种让函数式编程更容易理解的方式来看待函数。 什么是函数？函数是一个获取输入,调用参数,输出返回值的过程。函数有以下用途： 映射：基于输入产生输出。函数使输入和输出之间产生映射关系。 程序：函数被调用以执行一系列步骤。执行顺序被称为过程,这种编程方式被称为过程程序设计。 I/O:一些函数被用于与系统的其它部分通信,例如屏幕,存储,系统日志或者网络。 映射纯函数都是映射。函数映射输入参数为返回值,意味着对于每一组输入,都有一个输出值。函数会获取输入然后返回相关的输出。 `Math.max()`以数字为参数返回其中最大值： Math.max(2, 8, 5); // 8 在这个例子中,2、8和5是参数。它们是被传入函数的值。 `Math.max()`是一个传入任意个数字然后返回其中最大值的函数。在这里,我们传入的最大数字是8,这就是返回的数字。 函数在计算和数学中真的非常重要。它们帮助我们以有用的方式处理数据。好的程序员会给函数一个描述性的函数名,当我们看代码的时候可以看函数名就可以了解这个函数是做什么的。 数学中也有函数,而且运行方式和javascript中的函数非常相似。你很可能在代数中见过函数。它们就像下面这样： f(x) = 2x 这意味着我们正在声明一个名为f的函数,这个函数接收一个参数x,然后将x乘以2. 要使用这个函数,我们只需要为x提过一个值： f(2) 在代数中,这个和下面写的是相同的： 4 因此你可以在任何地方将f(2)替换成4. 现在让我们将这个函数转换为javascript: const double = x =&gt; x * 2; 你可以用`console.log()`检查这个函数的输出： console.log( double(5) ); // 10 还记得我说过在数学函数中你可以用4替换f(2)吗？在这里,javascript引擎将double(5)替换成答案10. 因此, `console.log( double(5) );`和`console.log(10);`是一样的。 这是正确的，因为`double()`是一个纯函数，但是如果`double()`有副作用，例如存储值到硬盘或者记录到控制台，你没办法只替换`double(5)` 为10而不改变原函数的意义。 如果你想要引用透明性（referential transparency），你需要使用纯函数。 纯函数一个纯函数是一个这样的函数： 相同的输入，总会返回相同的输出。 不会产生副作用。 如果一个函数被调用时没有用到返回值也是有意义的，那绝对是一个不纯的函数。对于纯函数，那就是一个空语句。 我建议你偏爱纯函数。意思是，如果用纯函数实现一个程序需求是可行的，那就用纯函数而不是其他选项。纯函数获得一些输入然后重要的设计原则是KISS (Keep It Simple, Stupid).我喜欢让它愚蠢的简单。纯函数用最可行的方式保持愚蠢的简单。 纯函数有很多有益的属性，这些属性形成了函数式编程的基础。纯函数完全独立于外部状态，因此纯函数可以免于由于共享可变状态造成的漏洞。纯函数的独立性使它成为多cpu和分布式计算集群中并发编程的不错选择，使他们成为很多类型的科学和资源密集型计算任务的必要部分。 纯函数也非常独立-易于在代码中移动，重构和重新组织，使你的程序更灵活，能够适应未来的变化。 共享状态的麻烦几年前我正在做一个能够让用户搜索音乐家然后加载这个音乐家的音乐列表到web播放器上的app。当时Google Instant刚刚推出，它会在您输入搜索查询时显示即时搜索结果。基于Ajax的自动补全突然风行一时。 唯一的问题是用户输入经常比自动补全搜索响应快，这会造成一些奇怪的错误。它会触发竞态条件，更新的建议会被过时的建议替换掉。 为什么会发生这种情况？ AJAX成功时的处理函数能够直接更新用户看到的列表。最慢的AJAX请求总是能通过盲目替换结果来赢得用户的注意，甚至会替换掉更新的结果。 任何种类的异步操作或并发会造成相似的竞态条件。竞态条件会在输出依赖于不受控事件（例如网络、设备延迟、用户输入、随机性等等）的顺序时发生。事实上，如果你使用共享状态而状态依赖于根据不确定性因素而变化的顺序时，总而言之，输出无法预测，也就意味着不可能进行适当的测试或完全理解。正如Martin Odersky所说： 非确定性 = 并行处理 + 共享状态 程序确定性通常是计算中一个理想的特性。或许你觉得这不是问题因为javascript是单线程，因此不会有并行处理问题，但是正如AJAX这个例子说明的，一个单线程js引擎并不意味着没有并发。事实正相反，JavaScript中有很多种并发。API I/O, event listeners, web workers, iframes, and timeouts都会给你的程序带来不可预测性。把它们和共享状态结合，你就得到了很多的错误。 纯函数可以帮你避免这类错误。 给定相同的输入，始终返回相同的输出使用`double()`函数时，你可以用结果替换函数调用，程序是相同的 — 在你的程序中`double(5)`和 `10` 意味着同一件事，无论上下文如何、无论何时调用、无论调用多少次。 但是你不能说所有的函数都是如此。一些函数不仅仅依赖传入的参数来产生输出。 想一想下面这个例子： Math.random(); // =&gt; 0.4011148700956255 Math.random(); // =&gt; 0.8533405303023756 Math.random(); // =&gt; 0.3550692005082965 即使我们没有传入任何值到函数中，它们都产生了不同的输出，意味着`Math.random()`不是纯的。 `Math.random()`每次运行时会产生一个新的介于0到1之间的随机值，因此很明显你不能用0.4011148700956255替换掉它而不使程序的含义发生变化。 那样每次就会产生相同的结果。我们每次向计算机请求一个随机数的时候，通常意味着我们想得到一个不同于上一次的结果。如果一对骰子的每一面都印着相同的数字，那还有什么意义呢？ 有时候我们会向计算机询问现在的时间。我们不会深究这个函数的实现细节。现在，复制下面的代码： const time = () =&gt; new Date().toLocaleTimeString(); time(); // =&gt; &quot;5:15:45 PM&quot; 如果你用现在的时间替换掉`time()`会发生什么？ 它会说是总是相同的时间：这个函数被替换的时间。换言之，它一天只能产生一次正确的输出，只有当你在这个函数被替换的精确时刻运行这个程序才行。 很清楚，`time()`函数不像`double()` 函数。 一个函数只有当给定相同的输入产生相同的输出时才是纯函数。你可能记得这条从代数课上学到的规则：相同的输入值总是映射到相同的输出值。然而，许多输入值可能映射到相同的输出值。例如，下面的函数时纯函数： const highpass = (cutoff, value) =&gt; value &gt;= cutoff; 相同的输入值总是会映射到相同的输出值： highpass(5, 5); // =&gt; true highpass(5, 5); // =&gt; true highpass(5, 5); // =&gt; true 许多输入值总是会映射到相同的输出值： highpass(5, 123); // true highpass(5, 6); // true highpass(5, 18); // true highpass(5, 1); // false highpass(5, 3); // false highpass(5, 4); // false 一个纯函数必须不依赖任何外部可变状态，因为那样的话它将不再具有确定性和引用透明性。 纯函数不产生副作用一个纯函数不产生任何副作用，意味着它不能改变任何外部状态。 不可变性JavaScript的对象参数是引用传递，意味着如果一个函数修改了对象或数组参数的属性,这将改变在函数外部可访问的状态。 相想下面这个改变，不纯的`addToCart()`函数: // impure addToCart mutates existing cart const addToCart = (cart, item, quantity) =&gt; { cart.items.push({ item, quantity }); return cart; }; test(&apos;addToCart()&apos;, assert =&gt; { const msg = &apos;addToCart() should add a new item to the cart.&apos;; const originalCart = { items: [] }; const cart = addToCart( originalCart, { name: &quot;Digital SLR Camera&quot;, price: &apos;1495&apos; }, 1 ); const expected = 1; // num items in cart const actual = cart.items.length; assert.equal(actual, expected, msg); assert.deepEqual(originalCart, cart, &apos;mutates original cart.&apos;); assert.end(); }); 这个函数传入了一个购物车，一个被放入购物车的项目和项目数量，然后返回了项目被添加后的同一个购物车。 问题是我们修改了一些共享状态。在这个函数被调用之前，其它函数也许依赖于那个购物车对象的状态，现在我们既然修改了那个共享状态，如果我们改变函数的调用顺序就不得不担心会对程序逻辑造成什么影响。重构代码可能会导致出现错误，这会搞砸订单引起顾客的不满。 现在考虑下面这个版本： // Pure addToCart() returns a new cart // It does not mutate the original. const addToCart = (cart, item, quantity) =&gt; { const newCart = lodash.cloneDeep(cart); newCart.items.push({ item, quantity }); return newCart; }; test(&apos;addToCart()&apos;, assert =&gt; { const msg = &apos;addToCart() should add a new item to the cart.&apos;; const originalCart = { items: [] }; // deep-freeze on npm // throws an error if original is mutated deepFreeze(originalCart); const cart = addToCart( originalCart, { name: &quot;Digital SLR Camera&quot;, price: &apos;1495&apos; }, 1 ); const expected = 1; // num items in cart const actual = cart.items.length; assert.equal(actual, expected, msg); assert.notDeepEqual(originalCart, cart, &apos;should not mutate original cart.&apos;); assert.end(); }); 在这个例子中，有一个嵌套在对象中的数组，这也是为什么我使用了深拷贝。这是一个比你通常要处理的状态更复杂的状态。对于大多数情况，你可以将它分成更小的块。 例如，Redux让你组合reducers而不是在每个reducer中处理整个应用的状态。结果就是当你每次更新状态中的一小部分时，你不必深拷贝整个应用状态。相反，你可以使用非破坏性的数组方法或者`Object.assign()`来更新应用状态的一小部分。 轮到你了，修改“这个非纯函数”为纯函数。使它在不修改测试代码的情况下通过单元测试。","categories":[],"tags":[]}]}