{"meta":{"title":"缥缈孤鸿影","subtitle":null,"description":null,"author":"SilentZhou","url":"https://www.blocknews.xyz"},"pages":[],"posts":[{"title":"《Babel插件手册》基础部分学习笔记","slug":"《Babel插件手册》学习笔记","date":"2021-01-28T10:02:30.000Z","updated":"2021-02-01T07:05:48.594Z","comments":true,"path":"2021/01/28/《Babel插件手册》学习笔记/","link":"","permalink":"https://www.blocknews.xyz/2021/01/28/《Babel插件手册》学习笔记/","excerpt":"介绍Babel是一个多用途JavaScript编译器。不仅如此，它还是一系列用于不同形式静态分析的模块集合。","text":"介绍Babel是一个多用途JavaScript编译器。不仅如此，它还是一系列用于不同形式静态分析的模块集合。 静态分析是在不执行代码的情况下对代码进行分析的过程。（执行代码的同时分析代码就是动态分析）静态分析的目的有很多。它可以用于代码检查，编译，代码高亮，代码转换，优化，压缩等等。 可以使用Babel构建许多提高效率写出更好程序的工具。 基础Babel是一个JavaScript编译器，尤其是一个source-to-source的编译器，通常又被称为转译器。这意味着你提供一些JavaScript代码给Babel，Babel修改并返回新的代码给你。 ASTs这些步骤都涉及到创建或者使用AST（Abstract Syntax Tree ）。AST由一个或者成百上千个Nodes组成。他们一起能够描述可用于静态分析的程序语法。 每个Node有如下接口： 123interface Node &#123; type: string;&#125; “type”字段是一个代表Node对象类型的字符串。（例如&quot;FunctionDeclaration&quot;, &quot;Identifier&quot;, or &quot;BinaryExpression&quot;)。每种类型的Node定义了一系列附加属性，用于描述该特定类型。 有一些附加属性是每个Node上都有的，Babel生成了这些属性用于描述Node在源码中的位置。 12345678910111213141516&#123; type: ..., start: 0, end: 38, loc: &#123; start: &#123; line: 1, column: 0 &#125;, end: &#123; line: 3, column: 1 &#125; &#125;, ...&#125; start, end, loc,这些属性每个Node上都有。 Babel的各个阶段Babel的三个主要阶段是parse，transform，generate。 ParseParse阶段接受代码输出AST。包括两个阶段： Lexical Analysis and Syntactic Analysis Lexical Analysis词法分析将一串代码转换为tokens流。 1n * n; 123456[ &#123; type: &#123; ... &#125;, value: \"n\", start: 0, end: 1, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: \"*\", start: 2, end: 3, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: \"n\", start: 4, end: 5, loc: &#123; ... &#125; &#125;, ...] 这里的每一个 type有一系列描述token的属性： 123456789101112131415161718ch of the types here have a set of properties describing the token:&#123; type: &#123; label: 'name', keyword: undefined, beforeExpr: false, startsExpr: true, rightAssociative: false, isLoop: false, isAssign: false, prefix: false, postfix: false, binop: null, updateContext: null &#125;, ...&#125; 和AST中的Nodes一样也有start, end, and loc. Syntactic Analysis语法分析将tokens流转换为AST。这个阶段利用tokens中的信息将它们重新格式化为AST，AST以一种更易于使用的方式来表示代码的结构。 TransformTransform阶段接受AST并遍历它，在遍历的过程中增加、更新、删除节点。目前为止，这是Babel或者其他任何编译器中最复杂的阶段。这是插件操作的地方，并且是这本手册的主题。所以我们现在不会太深入。 GenerateGenerate阶段将AST转换为code，同时生成source maps。 Traversal当你想转换AST时必须递归遍历树。 比如说 FunctionDeclaration这个类型。它有一些属性：id, params, and body。它们都有嵌套的节点。 1234567891011121314151617181920212223242526272829&#123; type: \"FunctionDeclaration\", id: &#123; type: \"Identifier\", name: \"square\" &#125;, params: [&#123; type: \"Identifier\", name: \"n\" &#125;], body: &#123; type: \"BlockStatement\", body: [&#123; type: \"ReturnStatement\", argument: &#123; type: \"BinaryExpression\", operator: \"*\", left: &#123; type: \"Identifier\", name: \"n\" &#125;, right: &#123; type: \"Identifier\", name: \"n\" &#125; &#125; &#125;] &#125;&#125; Visitors当我们说”going”一个节点，实际上指的是访问它们。这里使用了visitor pattern.访问者模式在不同语言的AST遍历中都有使用。简而言之，Visitors是对象，这个对象中定义了接收树中特殊节点的方法。如下： 12345678910const MyVisitor = &#123; Identifier() &#123; console.log(\"Called!\"); &#125;&#125;;// You can also create a visitor and add methods on it laterlet visitor = &#123;&#125;;visitor.MemberExpression = function() &#123;&#125;;visitor.FunctionDeclaration = function() &#123;&#125; 在下面的代码中， Identifier() 方法会被调用四次。 123function square(n) &#123; return n * n;&#125; 12345path.traverse(MyVisitor);Called!Called!Called!Called! 以上是在进入node的时候被调用的，也可以在离开node时被调用。 有如下树形结构： 12345678- FunctionDeclaration - Identifier (id) - Identifier (params[0]) - BlockStatement (body) - ReturnStatement (body) - BinaryExpression (argument) - Identifier (left) - Identifier (right) 遍历上面这棵树： Enter FunctionDeclaration Enter Identifier (id) Hit dead end Exit Identifier (id) Enter Identifier (params[0]) Hit dead end Exit Identifier (params[0]) Enter BlockStatement (body) Enter ReturnStatement (body) Enter BinaryExpression (argument) Enter Identifier (left) Hit dead end Exit Identifier (left) Enter Identifier (right) Hit dead end Exit Identifier (right) Exit BinaryExpression (argument) Exit ReturnStatement (body) Exit BlockStatement (body) Exit FunctionDeclaration 因此当创建一个visitor的时候有两次机会访问一个node。 12345678910const MyVisitor = &#123; Identifier: &#123; enter() &#123; console.log(\"Entered!\"); &#125;, exit() &#123; console.log(\"Exited!\"); &#125; &#125;&#125;; 使用 | 或别名，同一个方法可以作用于多种类型的节点： 123const MyVisitor = &#123; \"ExportNamedDeclaration|Flow\"(path) &#123;&#125;&#125;; Function是FunctionDeclaration, FunctionExpression, ArrowFunctionExpression, ObjectMethod and ClassMethod的别名： 123const MyVisitor = &#123; Function(path) &#123;&#125;&#125;; PathsAST中有许多Nodes，但是Nodes之间如何关联起来呢？我们可以使用Path，Path是一个呈现两个节点之间的关联的对象。 例如有如下节点和它的子节点： 12345678&#123; type: \"FunctionDeclaration\", id: &#123; type: \"Identifier\", name: \"square\" &#125;, ...&#125; 它的子节点Identifier 用path表示如下： 1234567891011&#123; \"parent\": &#123; \"type\": \"FunctionDeclaration\", \"id\": &#123;...&#125;, .... &#125;, \"node\": &#123; \"type\": \"Identifier\", \"name\": \"square\" &#125;&#125; Path还有其他元数据： 1234567891011121314151617181920212223&#123; \"parent\": &#123;...&#125;, \"node\": &#123;...&#125;, \"hub\": &#123;...&#125;, \"contexts\": [], \"data\": &#123;&#125;, \"shouldSkip\": false, \"shouldStop\": false, \"removed\": false, \"state\": null, \"opts\": null, \"skipKeys\": null, \"parentPath\": null, \"context\": null, \"container\": null, \"listKey\": null, \"inList\": false, \"parentKey\": null, \"key\": null, \"scope\": null, \"type\": null, \"typeAnnotation\": null&#125; 还有很多新增、更新、移动、移除节点的方法，后续会讨论。 某种意义上，paths是一个节点在树中的位置及各种相关信息的响应式呈现。当你调用了一个方法修改了树，相关的信息会更新。Babel帮你管理这一切更新，从而让使用node变得更容易并且尽可能无状态。 Paths in Visitors当你有一个Identifier()方法的visitor，你实际上是在访问path而不是node。 with the reactive representation of a node instead of the node itself. 12345const MyVisitor = &#123; Identifier(path) &#123; console.log(\"Visiting: \" + path.node.name); &#125;&#125;; 1a + b + c; 1234path.traverse(MyVisitor);Visiting: aVisiting: bVisiting: c StateState是AST转换的敌人。 例如如下代码: 123function square(n) &#123; return n * n;&#125; 写一个重新命名的visitor，将 n 转换为 x. 123456789101112131415let paramName;const MyVisitor = &#123; FunctionDeclaration(path) &#123; const param = path.node.params[0]; paramName = param.name; param.name = &quot;x&quot;; &#125;, Identifier(path) &#123; if (path.node.name === paramName) &#123; path.node.name = &quot;x&quot;; &#125; &#125;&#125;; 这对上面的例子有效，但是对于下面的代码就不对了： 1234function square(n) &#123; return n * n;&#125;n; 更好的处理方式是递归： 12345678910111213141516171819const updateParamNameVisitor = &#123; Identifier(path) &#123; if (path.node.name === this.paramName) &#123; path.node.name = &quot;x&quot;; &#125; &#125;&#125;;const MyVisitor = &#123; FunctionDeclaration(path) &#123; const param = path.node.params[0]; const paramName = param.name; param.name = &quot;x&quot;; path.traverse(updateParamNameVisitor, &#123; paramName &#125;); &#125;&#125;;path.traverse(MyVisitor); 这个例子证明了如何消除全局状态。 ScopesJavaScript 有 lexical scoping：123456789// global scopefunction scopeOne() &#123; // scope 1 function scopeTwo() &#123; // scope 2 &#125;&#125; 当我们转换代码时，需要小心作用域。我们需要确保修改代码的时候不会破坏已有的结构。 scope 可用如下形式表示： 1234567&#123; path: path, block: path.node, parentBlock: path.parent, parent: parentScope, bindings: [...]&#125; Bindings引用都属于特定的作用域，这种关系称之为bingding. 123456789function scopeOnce() &#123; var ref = \"This is a binding\"; ref; // This is a reference to a binding function scopeTwo() &#123; ref; // This is a reference to a binding from a lower scope &#125;&#125; 一个bingding看起来像这样： 12345678910111213&#123; identifier: node, scope: scope, path: path, kind: &apos;var&apos;, referenced: true, references: 3, referencePaths: [path, path, path], constant: false, constantViolations: [path]&#125;","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"Proxy与双向绑定","slug":"proxy与双向绑定","date":"2021-01-25T02:40:34.000Z","updated":"2021-02-01T04:06:24.933Z","comments":true,"path":"2021/01/25/proxy与双向绑定/","link":"","permalink":"https://www.blocknews.xyz/2021/01/25/proxy与双向绑定/","excerpt":"1 Proxy基础1.1 创建Proxy The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.","text":"1 Proxy基础1.1 创建Proxy The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object. Proxy由两个参数创建： target：被代理的原始对象 handler：一个定义哪些操作会被拦截和重新定义的对象 每个handler可以包含零个或多个捕获器,每个捕获器都对应一种基本操作,可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时,代理可以在这些操作传播到目标对象之前先调用捕获器函数,从而拦截并修改相应的行为。 12345678910111213141516171819202122232425const target = &#123; a: \"hehe\", b: \"haha\"&#125;;const handler = &#123; get: function(target, prop, receiver) &#123; return \"proxied: \"+target[prop]; &#125;, set:function(target,prop,value)&#123; if(prop in target)&#123; target[prop]=value &#125;else&#123; target[prop] = \"new prop\" &#125; return true &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.a) //proxied: heheproxy.b = 123proxy.c =3console.log(\"proxy\",proxy) //&#123; a: 'hehe', b: 123, c: 'new prop' &#125; 1.2 Reflect Reflect is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of proxy handlers. Reflect is not a function object, so it’s not constructible. 在Proxy中使用： 1234567891011121314const target = &#123; a: \"hehe\", b: \"haha\"&#125;;const handler = &#123; get: function(target, prop, receiver) &#123; return Reflect.get(target, prop, receiver) &#125;&#125;;const proxy2 = new Proxy(target, handler);console.log(proxy2.a) 返回对象的own keys： 123456const target = &#123; a: &quot;hehe&quot;, b: &quot;haha&quot;&#125;;Reflect.ownKeys(target);// [ &quot;a&quot;, &quot;b&quot; ] 1.3 可撤销代理1234567891011121314var revocable = Proxy.revocable(&#123;&#125;, &#123; get: function(target, name) &#123; return \"[[\" + name + \"]]\"; &#125;&#125;);var proxy = revocable.proxy;console.log(proxy.foo); // \"[[foo]]\"revocable.revoke();console.log(proxy.foo); // TypeError is thrownproxy.foo = 1 // TypeError againdelete proxy.foo; // still TypeErrortypeof proxy // \"object\", typeof doesn't trigger any trap 2 Proxy 应用2.1 双向绑定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;label for=\"price\"&gt;price:&lt;/label&gt;&lt;input id=\"price\" /&gt;&lt;label for=\"quantity\"&gt;quantity:&lt;/label&gt;&lt;input id=\"quantity\" /&gt;&lt;label for=\"total\"&gt;total:&lt;/label&gt;&lt;input id=\"total\" disabled /&gt;&lt;script&gt;let targetMap = new WeakMap();let usedReactivities = [];let effect = function(callback)&#123; usedReactivities=[] callback() for(let [target,prop] of usedReactivities)&#123; track(target,prop,callback) &#125;&#125;let track=function(target,prop,effect)&#123; if(!targetMap.has(target))&#123; targetMap.set(target,new Map()); &#125; if(!targetMap.get(target).has(prop))&#123; targetMap.get(target).set(prop,new Set()); &#125; let deps = targetMap.get(target).get(prop); deps.add(effect)&#125;let trigger=function(target,prop)&#123; if(!targetMap.has(target)||!targetMap.get(target).has(prop))&#123; return &#125; let deps = targetMap.get(target).get(prop); for(let effect of deps)&#123; effect() &#125;&#125;let handler = &#123; get:function(target,prop)&#123; usedReactivities.push([target,prop]) return Reflect.get(target,prop) &#125;, set:function(target,prop,value)&#123; target[prop] =value trigger(target,prop) return true &#125;,&#125;let product = &#123; price:5, quantity:2&#125;let total = 0;let proxyProduct =new Proxy(product,handler)let priceDom = document.getElementById(\"price\")let quantityDom = document.getElementById(\"quantity\")let totalDom = document.getElementById(\"total\")priceDom.addEventListener('input',event=&gt;&#123; proxyProduct.price= event.target.value&#125;)quantityDom.addEventListener('input',event=&gt;&#123; proxyProduct.quantity= event.target.value&#125;)effect(()=&gt;&#123; priceDom.value=proxyProduct.price&#125;)effect(()=&gt;&#123; quantityDom.value=proxyProduct.quantity&#125;)effect(()=&gt;&#123; console.log(\"effect callback start \",total) total = proxyProduct.price*proxyProduct.quantity totalDom.value=total console.log(\"effect callback end\",total)&#125;)&lt;/script&gt; codepen 2.2 案例：调色板codepen 参考资料Proxy-MDN Meta programming-MDN Reactivity in Depth Vue3 Reactivity","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"[译]什么是promise?","slug":"[译]什么是promise","date":"2019-02-04T03:58:39.000Z","updated":"2021-02-01T04:01:50.189Z","comments":true,"path":"2019/02/04/[译]什么是promise/","link":"","permalink":"https://www.blocknews.xyz/2019/02/04/[译]什么是promise/","excerpt":"Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。","text":"Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。 原文链接： Master the JavaScript Interview: What is a Promise?原文作者：Eric Elliott译者：SilentZhou Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。 什么是Promise?Promises是立刻执行的，意味着promise的构造函数一旦被调用它会立刻开始执行任何你给的任务。如果你需要懒执行,可以看看observables 或者tasks。 一个不完整的Promises历史Promises和futures(相似的概念)的早期实现于1980年代在MultiLisp和Concurrent Prolog这样的语言中出现的。“promise”这个词的使用最早是由 Barbara Liskov 和 Liuba Shrira 于1988年创造的。 我第一次在JavaScript中听说Promises的时候,Node还是一个全新的(事物),社区正在讨论处理异步行为的最佳方式。社区尝试过使用一段时间promises,但是最终选择了Node标准的错误优先回调。 与此同时,Dojo通过递延API添加了promises。(对promise的)兴趣和活动日益增长最终促使为了增加不同promise实现的互操作性的Promises/A规范的形成。 jQuery的异步操作基于promises进行了重构。jQuery的promise和Dojo的Deferred非常相似，由于jQuery一度非常流行它迅速成为最普遍使用的promise实现。然而，它不支持人们希望指望在其之上构建工具的两状态(执行态/拒绝态)链式调用和意外处理(https://blog.domenic.me/youre-missing-the-point-of-promises/)。。) 除了这些缺陷，jQuery正式让JavaScript promises成为主流，与此同时，更好的独立promise库例如Q和Bluebird变得非常流行。jQuery的promise实现的不兼容性激发了promise规范进行一些重要的澄清，promise因此被重写并被重新命名位Promise/A+规范。 ES6带来了兼容Promise/A+规范的全局Promise,其中一些非常重要的APIs建立在新标准Promise支持之上:特别是WHATWG Fetch规范和Async Functions标准(写作此文时处于阶段3草案)。 这里描述的是兼容Promise/A+规范,专注于ECMAScript标准实现的promises。 Promises是如何运行的Promise是一个能够同步返回异步函数的对象。它可能处于这三种状态之一： 执行态：onFulfilled()将会被调用(例如,resolve()被调用后) 拒绝态: onRejected())将会被调用(例如,reject()被调用后) 等待态: 还没有执行或拒绝 Promise如果没有处于等待(已经resolved或者rejected)那么就解决了。有时候人们使用resolved和settled表示同一件事：没有处于等待。 一旦解决,promise不能重新被解决。再次调用resolve()和reject()不会有效果。解决后promise的不可变性是一个重要特征。 原生JavaScript的promise不会暴露promise状态。相反,你最好把promise当作一个黑盒子。只有负责创建promise的函数才了解promise的状态，并有解决和拒绝的权限。 这是一个返回了promise的函数，返回的promise将在固定时间的延迟后解决： 123const wait = time =&gt; new Promise((resolve) =&gt; setTimeout(resolve, time));wait(3000).then(() =&gt; console.log('Hello!')); // 'Hello!' wait(3000)这个调用将在等待3000ms(3秒),然后打印Hello!。所有兼容规范的promise的都定义了一个.then()方法，该方法用于传递处理函数，处理函数可以接受解决值或拒绝值。 ES6的promise构造函数接受一个函数。该函数有两个参数，resolve()和reject()。在上面的例子中，我们只使用了resolve()，所以我们忽略了reject()。然后我们调用setTimeout()来形成延迟，然后当它结束时调用resolve()。 你可以将值传入resolve()或reject()，返回值将被传递到.then()方法的回调函数中。 当我使用reject()时，我总会传入一个Error对象。通常我希望有两种可能的解决状态：一种是正常的愉快之路，一种是例外——任何阻碍正常的愉快之路的情况。传入一个Error对象使情况更加明确。 重要的Promise规则Promise标准是由Promises/A+社区规范定义的。有许多遵照这个标准的实现，包括JavaScript标准的ECMAScript promises。 遵照规范的promises应该遵守一系列规则： promise或者thenable是一个提供了符合标准的.then()方法的对象。 等待态promise可以转变为执行或拒绝的状态。 一个执行态或拒绝态是已解决的，不能再转变为其它状态。 promise一旦解决，它必须有一个值(可以是undefined)。 这是所说的改变是用===来比较的。完成值可以是对象，对象的属性允许改变。 每一个promise必须提供一个具有以下特征的.then()方法： promise.then(onFulfilled?: Function,onRejected?: Function) =&gt; Promise .then()方法必须遵照以下规则： onFulfilled()和onRejected()都是可选参数。 如果提供的参数不是函数，则必须被忽略。 onFulfilled()将会在promise被执行后调用，promise的值将作为第一个参数。 onRejected()将会在promise被拒绝后调用，拒绝的理由将作为第一个参数。理由可以是任意的有效JavaScript值，但是因为拒绝本质上就是异常，我推荐使用Error对象。 onFulfilled()和onRejected()都只能最多被调用一次。 同一个promise可能调用多次.then()。换言之，promise可以被用来汇总回调函数。 .then()方法必须返回一个新的promise:promise2。 如果onFulfilled()或onRejected()有一个返回值x，并且x是一个promise，promise2将锁定为x(假定与x有相同的状态和值)。否则,promise2将被执行且值是x。 如果onFulfilled()或onRejected()抛出一个异常e,promise2必须以e作为理由被拒绝。 如果onFulfilled()不是一个函数并且promise1已经被执行，promise2则必须以同promise1相同的值被执行。 如果onRejected()不是一个函数并且promise1已经被拒绝，promise2则必须以同promise1相同的理由被拒绝。 Promise链因为.then()总是返回一个新的promise，那么精确控制如何处理和在什么地方处理错误链式调用Promise。Promises允许你模仿同步代码的try/catch行为。 和同步代码一样，链式调用会形成顺序执行。换言之，你可以这样做： fetch(url).then(process).then(save).catch(handleErrors); 假设每一个函数,fetch(),process(),和save()都返回promises, process()将等待fetch()完成再开始,save()将等待process()完成再开始。handleErrors()只会当前面任意一个promise拒绝时才执行。 这是一个多次拒绝的复杂promise链的例子： 123456789101112131415161718192021222324252627282930313233343536const wait = time =&gt; new Promise( res =&gt; setTimeout(() =&gt; res(), time));wait(200) // onFulfilled() can return a new promise, `x` .then(() =&gt; new Promise(res =&gt; res('foo'))) // the next promise will assume the state of `x` .then(a =&gt; a) // Above we returned the unwrapped value of `x` // so `.then()` above returns a fulfilled promise // with that value: .then(b =&gt; console.log(b)) // 'foo' // Note that `null` is a valid promise value: .then(() =&gt; null) .then(c =&gt; console.log(c)) // null // The following error is not reported yet: .then(() =&gt; &#123;throw new Error('foo');&#125;) // Instead, the returned promise is rejected // with the error as the reason: .then( // Nothing is logged here due to the error above: d =&gt; console.log(`d: $&#123; d &#125;`), // Now we handle the error (rejection reason) e =&gt; console.log(e)) // [Error: foo] // With the previous exception handled, we can continue: .then(f =&gt; console.log(`f: $&#123; f &#125;`)) // f: undefined // The following doesn't log. e was already handled, // so this handler doesn't get called: .catch(e =&gt; console.log(e)) .then(() =&gt; &#123; throw new Error('bar'); &#125;) // When a promise is rejected, success handlers get skipped. // Nothing logs here because of the 'bar' exception: .then(g =&gt; console.log(`g: $&#123; g &#125;`)) .catch(h =&gt; console.log(h)) // [Error: bar]; 错误处理请注意promises同时具有成功和错误处理函数，很容易见到下面这样的代码： save().then(handleSuccess,handleError); 但是如果handleSuccess()抛出了错误该怎么办?从.then()返回的promise会被拒绝，但是没办法捕捉到这个拒绝——意味着一个错误在你的app中被吞没了。天哪！ 因为这个原因，一些人认为上面的代码是反模式的，并且推荐下面的写法： save().then(handleSuccess).catch(handleError); 其中的区别是微妙但重要的。在第一个例子中，源自save()操作的错误将被捕获，但是源自handleSuccess()函数的错误将被吞没。 在第二个例子中，.catch()将会处理来自save()或handleSuccess()的拒绝。 当然，save()错误可能是网络错误，而handleSuccess()错误可能是因为开发者忘记处理特定的状态码。如果你想以不同方式处理他们呢?你可以选择同时处理他们： save().then(handleSuccess,handleNetworkError) .catch(handleProgrammerError); 无论你喜欢哪种方式，我建议在所有promise链的末尾加上.catch()。值得重复一遍： 我建议在所有promise链的末尾加上.catch()。 我如何取消一个promise？Promise的新用户经常想知道的第一件事是如何取消一个promise。这有个主意：只需要以取消为理由拒绝这个promise。如果你需要以不同于寻常错误的方式来处理它，那么你可以在你的错误处理程序中新建一个分支。 这里是一些人们取消promise时犯的常见错误： 在promise上添加.cancel()添加.cancel()让promise变得不合标准，而且同时也打破了另一条promise的规则：只有创建promise的函数才能够解决，拒绝，取消promise。暴露它破坏了封装性，并且鼓励人们在他们不应该知道的地方编写操作promise的代码。应该避免面条代码和破坏promise。 忘记清除一些聪明人已经明白有办法利用Promise.race()作为取消机制。这里的问题是取消控制在创建promise的函数中进行，这个函数是唯一可以进行适当清理活动的地方，例如清除超时或者通过清除对数据的引用来释放内存，等等… 忘记处理被拒绝的取消promise你知道当你忘记处理被拒绝的promise时Chrome会一直在控制台发出警告消息吗？天哪！ 过于复杂撤销的TC39提案提出了一个单独的消息通道用于取消。它使用了一个称作取消令牌的新概念。在我看来，这个方案会让promise规范变得相当臃肿。它提供的原有规范不支持的唯一特征是拒绝和取消的分离，但在我看来，这是一开始就没必要的。 你想根据是否有异常或取消来切换处理方式吗？是的，当然。但这是promise的工作吗？在我看来,不，它不是。 重新思考promise的取消通常，我会在promise创建时传入所有promise决定如何解决/拒绝/取消所需要的信息。那样的话，promise不需要一个.cancel()方法。你可能奇怪如何在promise创建时就知道是否需要取消。 “如果我不确定是否要取消，我怎么知道在promise创建时传入什么？” 如果存在一种对象可以代表未来的一个值… oh，等等。 我们传入的代表是否取消的值自身也可以是一个promise。它看起来可能是这样的： 1234567891011121314151617181920const wait = ( time, cancel = Promise.reject()) =&gt; new Promise((resolve, reject) =&gt; &#123; const timer = setTimeout(resolve, time); const noop = () =&gt; &#123;&#125;; cancel.then(() =&gt; &#123; clearTimeout(timer); reject(new Error('Cancelled')); &#125;, noop);&#125;);const shouldCancel = Promise.resolve(); // Yes, cancel// const shouldCancel = Promise.reject(); // No cancelwait(2000, shouldCancel).then( () =&gt; console.log('Hello!'), (e) =&gt; console.log(e) // [Error: Cancelled]); 我们使用默认参数使它默认不取消。它使cancel参数变成方便的可选参数。然后我们像之前一样设置超时，但是这次我们保存了超时计时的ID以便之后清除。 我们使用cancel.then()方法来处理取消和资源清理。这个方法只会在promise有机会解决之前被取消时才会运行。如果你取消得太晚，你会错过机会。火车已经驶离站台了。 注意：你可能想知道noop()函数是干什么的。noop这个词的意思是空操作，意味着函数什么也不做。如果没有它，V8会抛出警告消息：UnhandledPromiseRejectionWarning: Unhandled promise rejection。始终处理promise拒绝是一个好主意，即使处理函数是一个noop()。 概括promise的取消这对于wait()计时器是很好的，但我们还可以进一步抽象出来封装所有你不得不记住的事： cancel promise的默认状态为拒绝——如果没有传入cancel promise，我们不想取消或出现错误。 当你拒绝取消时请记得执行清理。 请记住，onCancel清理时自身可能会产生错误，这个错误也需要处理。(请注意在上面的等待例子中错误处理被省略了——它很容易被忘记!) 让我们创建一个可以取消promise的基础工具，它可以用来包裹任何promise。例如，处理网络申请，等等…它看起来像这样： speculation(fn: SpecFunction, shouldCancel: Promise) =&gt; Promise SpecFunction就像你传入Promise构造函数的函数一样，只有一点不同——它有一个onCancel()处理函数： SpecFunction(resolve: Function, reject: Function, onCancel: Function) =&gt; Void 12345678910111213141516171819202122// HOF Wraps the native Promise API// to add take a shouldCancel promise and add// an onCancel() callback.const speculation = ( fn, cancel = Promise.reject() // Don't cancel by default) =&gt; new Promise((resolve, reject) =&gt; &#123; const noop = () =&gt; &#123;&#125;; const onCancel = ( handleCancel ) =&gt; cancel.then( handleCancel, // Ignore expected cancel rejections: noop ) // handle onCancel errors .catch(e =&gt; reject(e)) ; fn(resolve, reject, onCancel);&#125;); 请注意，这只是一个告诉你它工作原理的要点的例子。你还需要考虑许多其它边缘情况。例如，在这个例子中，如果你在promise已经解决后取消promise，handleCancel将会被调用。 我将这些边缘情况实现了一个在维护的生产版本作为开源库，Speculation。 让我们使用改进的库来重写可取消的wait()程序。首先安装speculation： npm install –save speculation 现在你可以引入并使用它： 12345678910111213141516171819202122232425import speculation from 'speculation';const wait = ( time, cancel = Promise.reject() // By default, don't cancel) =&gt; speculation((resolve, reject, onCancel) =&gt; &#123; const timer = setTimeout(resolve, time); // Use onCancel to clean up any lingering resources // and then call reject(). You can pass a custom reason. onCancel(() =&gt; &#123; clearTimeout(timer); reject(new Error('Cancelled')); &#125;);&#125;, cancel); // remember to pass in cancel!wait(200, wait(500)).then( () =&gt; console.log('Hello!'), (e) =&gt; console.log(e)); // 'Hello!'wait(200, wait(50)).then( () =&gt; console.log('Hello!'), (e) =&gt; console.log(e)); // [Error: Cancelled] 这样就简化了许多，因为你不需要担心noop(),在onCancel()中捕捉错误或者其它边缘情况。那些细节已经被speculation()提取出来了。看看这个，在真实项目中自由使用它吧。 原生JS Promise的额外内容原生Promise对象有一些你可能感兴趣的其它内容： Promise.reject()返回一个被拒绝的promise。 Promise.resolve()返回一个被解决的promise。 Promise.race()接受一个数组(或任何可迭代对象)，返回一个promise，这个promise将会在第一个解决promise之后以相同的值解决，或者在第一个拒绝的promise之后以相同的理由拒绝。 Promise.all()接受一个数组(或任何可迭代对象)，返回一个promise，这个promise将会在所有可迭代参数的promises解决之后解决，或者在第一个拒绝的promise之后以相同的理由拒绝。 结论Promises已经变成JavaScript中几个习惯用法的一部分，包括用于现代ajax请求的WHATWG Fetch标准，和用于让异步代码看起来像同步代码的Async Functions标准。 写这篇文章的时候Async functions处于第3阶段，但是我预计它们会很快变成JavaScript中一个流行的，常用的异步编程解决方案——意味着对于JavaScript开发者，学习领会promises将在不远的将来变得更加重要。 例如，如果你正在使用Redux,我建议你看看redux-saga:一个用于管理Redux中副作用的库,纵观文档它依赖于async functions。 我希望即使是有经验的promise使用者在阅读完本文后，对于什么是promise、promise的工作原理以及如何更好地使用promise能够有更好的了解。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"[译]什么是纯函数?","slug":"译-什么是纯函数","date":"2019-01-23T01:56:37.000Z","updated":"2019-01-23T09:03:40.000Z","comments":true,"path":"2019/01/23/译-什么是纯函数/","link":"","permalink":"https://www.blocknews.xyz/2019/01/23/译-什么是纯函数/","excerpt":"纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？","text":"纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？ 原文链接： Master the JavaScript Interview: What is a Pure Function?原文作者：Eric Elliott译者：SilentZhou 纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？ 通过一个免费课程 “Learn JavaScript with Eric Elliott”:我们能够回答这个问题。 在我们掌握什么是纯函数之前,让我们先仔细看看什么是函数。或许有一种让函数式编程更容易理解的方式来看待函数。 什么是函数？函数是一个获取输入,调用参数,输出返回值的过程。函数有以下用途： 映射：基于输入产生输出。函数使输入和输出之间产生映射关系。 程序：函数被调用以执行一系列步骤。执行顺序被称为过程,这种编程方式被称为过程程序设计。 I/O:一些函数被用于与系统的其它部分通信,例如屏幕,存储,系统日志或者网络。 映射纯函数都是映射。函数映射输入参数为返回值,意味着对于每一组输入,都有一个输出值。函数会获取输入然后返回相关的输出。 `Math.max()`以数字为参数返回其中最大值： Math.max(2, 8, 5); // 8 在这个例子中,2、8和5是参数。它们是被传入函数的值。 `Math.max()`是一个传入任意个数字然后返回其中最大值的函数。在这里,我们传入的最大数字是8,这就是返回的数字。 函数在计算和数学中真的非常重要。它们帮助我们以有用的方式处理数据。好的程序员会给函数一个描述性的函数名,当我们看代码的时候可以看函数名就可以了解这个函数是做什么的。 数学中也有函数,而且运行方式和javascript中的函数非常相似。你很可能在代数中见过函数。它们就像下面这样： f(x) = 2x 这意味着我们正在声明一个名为f的函数,这个函数接收一个参数x,然后将x乘以2. 要使用这个函数,我们只需要为x提过一个值： f(2) 在代数中,这个和下面写的是相同的： 4 因此你可以在任何地方将f(2)替换成4. 现在让我们将这个函数转换为javascript: const double = x =&gt; x * 2; 你可以用`console.log()`检查这个函数的输出： console.log( double(5) ); // 10 还记得我说过在数学函数中你可以用4替换f(2)吗？在这里,javascript引擎将double(5)替换成答案10. 因此, `console.log( double(5) );`和`console.log(10);`是一样的。 这是正确的，因为`double()`是一个纯函数，但是如果`double()`有副作用，例如存储值到硬盘或者记录到控制台，你没办法只替换`double(5)` 为10而不改变原函数的意义。 如果你想要引用透明性（referential transparency），你需要使用纯函数。 纯函数一个纯函数是一个这样的函数： 相同的输入，总会返回相同的输出。 不会产生副作用。 如果一个函数被调用时没有用到返回值也是有意义的，那绝对是一个不纯的函数。对于纯函数，那就是一个空语句。 我建议你偏爱纯函数。意思是，如果用纯函数实现一个程序需求是可行的，那就用纯函数而不是其他选项。纯函数获得一些输入然后重要的设计原则是KISS (Keep It Simple, Stupid).我喜欢让它愚蠢的简单。纯函数用最可行的方式保持愚蠢的简单。 纯函数有很多有益的属性，这些属性形成了函数式编程的基础。纯函数完全独立于外部状态，因此纯函数可以免于由于共享可变状态造成的漏洞。纯函数的独立性使它成为多cpu和分布式计算集群中并发编程的不错选择，使他们成为很多类型的科学和资源密集型计算任务的必要部分。 纯函数也非常独立-易于在代码中移动，重构和重新组织，使你的程序更灵活，能够适应未来的变化。 共享状态的麻烦几年前我正在做一个能够让用户搜索音乐家然后加载这个音乐家的音乐列表到web播放器上的app。当时Google Instant刚刚推出，它会在您输入搜索查询时显示即时搜索结果。基于Ajax的自动补全突然风行一时。 唯一的问题是用户输入经常比自动补全搜索响应快，这会造成一些奇怪的错误。它会触发竞态条件，更新的建议会被过时的建议替换掉。 为什么会发生这种情况？ AJAX成功时的处理函数能够直接更新用户看到的列表。最慢的AJAX请求总是能通过盲目替换结果来赢得用户的注意，甚至会替换掉更新的结果。 任何种类的异步操作或并发会造成相似的竞态条件。竞态条件会在输出依赖于不受控事件（例如网络、设备延迟、用户输入、随机性等等）的顺序时发生。事实上，如果你使用共享状态而状态依赖于根据不确定性因素而变化的顺序时，总而言之，输出无法预测，也就意味着不可能进行适当的测试或完全理解。正如Martin Odersky所说： 非确定性 = 并行处理 + 共享状态 程序确定性通常是计算中一个理想的特性。或许你觉得这不是问题因为javascript是单线程，因此不会有并行处理问题，但是正如AJAX这个例子说明的，一个单线程js引擎并不意味着没有并发。事实正相反，JavaScript中有很多种并发。API I/O, event listeners, web workers, iframes, and timeouts都会给你的程序带来不可预测性。把它们和共享状态结合，你就得到了很多的错误。 纯函数可以帮你避免这类错误。 给定相同的输入，始终返回相同的输出使用`double()`函数时，你可以用结果替换函数调用，程序是相同的 — 在你的程序中`double(5)`和 `10` 意味着同一件事，无论上下文如何、无论何时调用、无论调用多少次。 但是你不能说所有的函数都是如此。一些函数不仅仅依赖传入的参数来产生输出。 想一想下面这个例子： Math.random(); // =&gt; 0.4011148700956255 Math.random(); // =&gt; 0.8533405303023756 Math.random(); // =&gt; 0.3550692005082965 即使我们没有传入任何值到函数中，它们都产生了不同的输出，意味着`Math.random()`不是纯的。 `Math.random()`每次运行时会产生一个新的介于0到1之间的随机值，因此很明显你不能用0.4011148700956255替换掉它而不使程序的含义发生变化。 那样每次就会产生相同的结果。我们每次向计算机请求一个随机数的时候，通常意味着我们想得到一个不同于上一次的结果。如果一对骰子的每一面都印着相同的数字，那还有什么意义呢？ 有时候我们会向计算机询问现在的时间。我们不会深究这个函数的实现细节。现在，复制下面的代码： const time = () =&gt; new Date().toLocaleTimeString(); time(); // =&gt; &quot;5:15:45 PM&quot; 如果你用现在的时间替换掉`time()`会发生什么？ 它会说是总是相同的时间：这个函数被替换的时间。换言之，它一天只能产生一次正确的输出，只有当你在这个函数被替换的精确时刻运行这个程序才行。 很清楚，`time()`函数不像`double()` 函数。 一个函数只有当给定相同的输入产生相同的输出时才是纯函数。你可能记得这条从代数课上学到的规则：相同的输入值总是映射到相同的输出值。然而，许多输入值可能映射到相同的输出值。例如，下面的函数时纯函数： const highpass = (cutoff, value) =&gt; value &gt;= cutoff; 相同的输入值总是会映射到相同的输出值： highpass(5, 5); // =&gt; true highpass(5, 5); // =&gt; true highpass(5, 5); // =&gt; true 许多输入值总是会映射到相同的输出值： highpass(5, 123); // true highpass(5, 6); // true highpass(5, 18); // true highpass(5, 1); // false highpass(5, 3); // false highpass(5, 4); // false 一个纯函数必须不依赖任何外部可变状态，因为那样的话它将不再具有确定性和引用透明性。 纯函数不产生副作用一个纯函数不产生任何副作用，意味着它不能改变任何外部状态。 不可变性JavaScript的对象参数是引用传递，意味着如果一个函数修改了对象或数组参数的属性,这将改变在函数外部可访问的状态。 相想下面这个改变，不纯的`addToCart()`函数: // impure addToCart mutates existing cart const addToCart = (cart, item, quantity) =&gt; { cart.items.push({ item, quantity }); return cart; }; test(&apos;addToCart()&apos;, assert =&gt; { const msg = &apos;addToCart() should add a new item to the cart.&apos;; const originalCart = { items: [] }; const cart = addToCart( originalCart, { name: &quot;Digital SLR Camera&quot;, price: &apos;1495&apos; }, 1 ); const expected = 1; // num items in cart const actual = cart.items.length; assert.equal(actual, expected, msg); assert.deepEqual(originalCart, cart, &apos;mutates original cart.&apos;); assert.end(); }); 这个函数传入了一个购物车，一个被放入购物车的项目和项目数量，然后返回了项目被添加后的同一个购物车。 问题是我们修改了一些共享状态。在这个函数被调用之前，其它函数也许依赖于那个购物车对象的状态，现在我们既然修改了那个共享状态，如果我们改变函数的调用顺序就不得不担心会对程序逻辑造成什么影响。重构代码可能会导致出现错误，这会搞砸订单引起顾客的不满。 现在考虑下面这个版本： // Pure addToCart() returns a new cart // It does not mutate the original. const addToCart = (cart, item, quantity) =&gt; { const newCart = lodash.cloneDeep(cart); newCart.items.push({ item, quantity }); return newCart; }; test(&apos;addToCart()&apos;, assert =&gt; { const msg = &apos;addToCart() should add a new item to the cart.&apos;; const originalCart = { items: [] }; // deep-freeze on npm // throws an error if original is mutated deepFreeze(originalCart); const cart = addToCart( originalCart, { name: &quot;Digital SLR Camera&quot;, price: &apos;1495&apos; }, 1 ); const expected = 1; // num items in cart const actual = cart.items.length; assert.equal(actual, expected, msg); assert.notDeepEqual(originalCart, cart, &apos;should not mutate original cart.&apos;); assert.end(); }); 在这个例子中，有一个嵌套在对象中的数组，这也是为什么我使用了深拷贝。这是一个比你通常要处理的状态更复杂的状态。对于大多数情况，你可以将它分成更小的块。 例如，Redux让你组合reducers而不是在每个reducer中处理整个应用的状态。结果就是当你每次更新状态中的一小部分时，你不必深拷贝整个应用状态。相反，你可以使用非破坏性的数组方法或者`Object.assign()`来更新应用状态的一小部分。 轮到你了，修改“这个非纯函数”为纯函数。使它在不修改测试代码的情况下通过单元测试。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"我们还要再等30年吗?","slug":"我们还要再等30年吗","date":"2018-09-25T07:18:00.000Z","updated":"2019-01-23T09:03:42.000Z","comments":true,"path":"2018/09/25/我们还要再等30年吗/","link":"","permalink":"https://www.blocknews.xyz/2018/09/25/我们还要再等30年吗/","excerpt":"我是一个假乐迷。去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。","text":"我是一个假乐迷。去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。 我是一个假乐迷。 去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。然而，即使是他们的歌，我也谈不上非常熟悉。我勉强挤在外围，不敢太靠近舞台，靠近舞台的是一听前奏就开始摇头晃脑跟着哼唱的核心歌迷。其实我不常听歌，唱歌五音不全，喜欢他们的歌因为歌中表达的东西。","categories":[{"name":"life","slug":"life","permalink":"https://www.blocknews.xyz/categories/life/"}],"tags":[{"name":"music","slug":"music","permalink":"https://www.blocknews.xyz/tags/music/"}]}]}