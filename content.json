{"meta":{"title":"缥缈孤鸿影","subtitle":null,"description":null,"author":"SilentZhou","url":"https://www.blocknews.xyz"},"pages":[],"posts":[{"title":"JS表达式语句-学习笔记","slug":"JS表达式语句","date":"2021-02-08T07:31:12.000Z","updated":"2021-02-18T03:14:18.404Z","comments":true,"path":"2021/02/08/JS表达式语句/","link":"","permalink":"https://www.blocknews.xyz/2021/02/08/JS表达式语句/","excerpt":"什么是表达式语句表达式语句实际上就是一个表达式，它是由运算符连接变量或者直接量构成的。","text":"什么是表达式语句表达式语句实际上就是一个表达式，它是由运算符连接变量或者直接量构成的。 PrimaryExpressionPrimary Expression 是表达式的最小单位，它所涉及的语法结构也是优先级最高的。Primary Expression 包含了各种“直接量”，直接量就是直接用某种语法写出来的具有特定类型的值。 基本类型直接量: 12345\"abc\";123;null;true;false; 直接量的形式定义对象: 12345(&#123;&#125;);(function()&#123;&#125;);(class&#123; &#125;);[];/abc/g; this 或者变量 12this;myVar; 圆括号，可以改变运算顺序 1(a + b); MemberExpression 成员表达式1234a.b;a[\"b\"];new.target;super.b; new.target用于判断函数是否被new 调用，super 则是构造函数中，用于访问父类的属性的语法。 Member Expression 最初设计是为了属性访问的，不过从语法结构需要，以下两种在 JavaScript 标准中当做 Member Expression。 这是一个是带函数的模板，这个带函数名的模板表示把模板的各个部分算好后传递给一个函数。 1f`a$&#123;b&#125;c`; 另一个是带参数列表的 new 运算 1new Cls(); NewExpression NEW 表达式这里的 New Expression 特指没有参数列表的表达式。 1new new Cls(1);// =&gt; new (new Cls(1)) 12345678910111213141516171819class Cls&#123; constructor(n)&#123; console.log(\"cls\",n) return class&#123; constructor(n)&#123; console.log(\"returned\",n) &#125; &#125; &#125;&#125;new new Cls(1)// cls 1// returned undefinednew (new Cls)(1)// cls undefined// returned 1 CallExpression 函数调用表达式Member Expression 后加一个括号里的参数列表可以构成Call Expression。 1234567a.b(c);super();a.b(c)(d)(e);a.b(c)[3];a.b(c).d;a.b(c)`xyz`; LeftHandSideExpression 左值表达式New Expression 和 Call Expression 统称 LeftHandSideExpression，左值表达式。 左值表达式就是可以放到等号左边的表达式,最经典的用法是用于构成赋值表达式 1a().c = b; AssignmentExpression 赋值表达式1a = b 连续赋值，是右结合的，先把 d 的结果赋值给 c，再把整个表达式的结果赋值给 b，再赋值给 a： 12a = b = c = da = (b = (c = d)) //等于上面 结合一些运算符 1a += b; // a = a + b; 能有这样用的运算符有下面这几种：*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|=、**= 更新表达式 UpdateExpression左值表达式搭配 ++ – 运算符，可以形成更新表达式。 1234-- a;++ a;a --a ++ 一元运算表达式 UnaryExpression12345678delete a.b;void a;typeof a;- a;~ a;! a;await a; 乘方表达式 ExponentiationExpression** 运算是右结合的 123++i ** 302 ** 30 //正确-2 ** 30 //报错 -2 这样的一元运算表达式，是不可以放入乘方表达式的，如果需要表达类似的逻辑，必须加括号。 乘法表达式 MultiplicativeExpression乘法表达式有三种运算符： 1234x * 2;y / 3;z % 4; 加法表达式 AdditiveExpression加法表达式是由乘法表达式用加号或者减号连接构成的。 1a + b * c 移位表达式 ShiftExpression移位运算把操作数看做二进制表示的整数，然后移动特定位数。所以左移 n 位相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n 次。普通移位会保持正负数。无符号移位会把减号视为符号位 1，同时参与移位。 1234567891011&lt;&lt; 向左移位&gt;&gt; 向右移位&gt;&gt;&gt; 无符号向右移位console.log(1 &lt;&lt; 2) //4console.log(-1 &lt;&lt; 2) // -4console.log(8 &gt;&gt; 2)// 2console.log(-8 &gt;&gt; 2) // -2console.log(1 &gt;&gt;&gt;1) // 0console.log(-1 &gt;&gt;&gt;1) // 2147483647 关系表达式 RelationalExpression移位表达式可以构成关系表达式，这里的关系表达式就是大于、小于、大于等于、小于等于等运算符号连接，统称为关系运算。 123456&lt;=&gt;=&lt;&gt;instanceof in 相等表达式 EqualityExpression1a instanceof \"object\" == true 四种运算符：==、!=、===、!== 位运算表达式位运算表达式含有三种： 按位与表达式 BitwiseANDExpression 按位异或表达式 BitwiseANDExpression 按位或表达式 BitwiseORExpression 按位与运算符（&amp;）、按位异或运算符（^）、按位或运算符（|） 逻辑与表达式和逻辑或表达式这两种表达式都不会做类型转换，所以尽管是逻辑运算，但是最终的结果可能是其它类型。 12false || 1;false &amp;&amp; undefined; 条件表达式 ConditionalExpression条件表达式由逻辑或表达式和条件运算符构成，条件运算符又称三目运算符，它有三个部分，由两个运算符?和:配合使用。 1condition ? branch1 : branch2 条件表达式也像逻辑表达式一样，可能忽略后面表达式的计算。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"JS语句-学习笔记","slug":"JS语句","date":"2021-02-06T05:03:12.000Z","updated":"2021-02-18T03:15:41.918Z","comments":true,"path":"2021/02/06/JS语句/","link":"","permalink":"https://www.blocknews.xyz/2021/02/06/JS语句/","excerpt":"StatementGrammar 简单语句 组合语句 声明","text":"StatementGrammar 简单语句 组合语句 声明 Runtime Completion Record Lexical Environment Completion Record12If(x == 1) return 10; [[type]]: normal,break,continue,return,or throw [[value]]: 基本类型 [[target]]: label 简单语句 ExpressionStatement EmptyStatement DebuggerStatement ThrowStatement ContinueStatement BreakStatement ReturnStatement 复合语句 BlockStatement IfStatement SwitchStatement IterationStatement WithStatement LabelledStatement TryStatement 声明 FunctionDeclaration GeneratorDeclaration AsyncGeneratorDeclaration VariableStatement ClassDeclaration LexicalDeclaration 预处理1234567var a= 2;void function()&#123; a = 1; return; var a;&#125;();console.log(a); // 2 1234567var a= 2;void function()&#123; a = 1; return; const a;&#125;();console.log(a); // SyntaxError: Missing initializer in const declaration 作用域var的作用域是函数体内，const的作用域是花括号内。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"JS类型转换学习笔记","slug":"JS类型转换","date":"2021-02-06T03:18:12.000Z","updated":"2021-02-18T03:19:48.266Z","comments":true,"path":"2021/02/06/JS类型转换/","link":"","permalink":"https://www.blocknews.xyz/2021/02/06/JS类型转换/","excerpt":"Type Conversion + a+b + “false” == false + ap[o] = 1;","text":"Type Conversion + a+b + “false” == false + ap[o] = 1; Null Undefined Boolean(True) Boolean(false) Number String Symbol Object Boolean FALSE FALSE - - 0/NAN-false “”-false TRUE True Number 0 NaN 1 0 - StringToNumber TypeError 拆箱转换 String “null” “undefined” TRUE FALSE NumbetToString - TypeError 拆箱转换 Object TypeError TypeError 装箱转换 装箱转换 装箱转换 装箱转换 装箱转换 - Unboxing ToPremitive toString vs valueOf Symbol.toPrimitive 12345678910111213var o = &#123; [Symbol.toPrimitive]()&#123; return 3&#125;, toString()&#123;return \"2\"&#125;, valueOf()&#123; return 1&#125;,&#125;var x=&#123;&#125;x[o]=1 // 属性，优先调用Symbol.toPrimitive，其次是toStringconsole.log(\"a\"+o) // 加法，优先调用Symbol.toPrimitive，其次是valueOfconsole.log(x) Boxing 类型 对象 值 Number new Number(1) 1 String new String(“a”) “a” Boolean new Boolean(true) true Symbol new Object(Symbol(“a”)) Symbol(“a”)","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"Dynamic Imports","slug":"Dynamic Imports","date":"2021-02-02T11:47:12.000Z","updated":"2021-02-02T11:47:08.934Z","comments":true,"path":"2021/02/02/Dynamic Imports/","link":"","permalink":"https://www.blocknews.xyz/2021/02/02/Dynamic Imports/","excerpt":"什么是Dynamic ImportsDynamic Imports即动态导入，关键字import可以像调用函数一样动态的导入模块。使用这种方式时，返回值是promise。 1234import('/modules/my-module.js') .then((module) =&gt; &#123; // Do something with the module. &#125;);","text":"什么是Dynamic ImportsDynamic Imports即动态导入，关键字import可以像调用函数一样动态的导入模块。使用这种方式时，返回值是promise。 1234import('/modules/my-module.js') .then((module) =&gt; &#123; // Do something with the module. &#125;); 也支持await关键字。 1let module = await import('/modules/my-module.js'); 设计动机和使用场景静态import能够满足90%的使用场景，并且对静态分析和tree shaking提供了很好的支持。 但是有时候需要在运行时动态导入模块，以下是可能的使用场景： 当静态导入显著减慢代码的加载速度并且很有可能不会用到或者一段时间后才会用到。 当静态导入显著增加了程序的内存占用并且很有可能不会用到。 当你需要导入的模块在加载时不存在,需要异步导入时 当导入模块的说明符，需要动态构建。（静态导入只能使用静态说明符） 当被导入的模块有副作用，这些副作用只有在触发了某些条件才被需要时。 import()和import的区别 import()不仅在modules中可以使用，也可以在scripts中使用。 如果是在module中使用，可以出现在任何位置，不会发生提升。 import()接受任意字符串（包括运行时确定的模板字符串），不仅仅是静态字符串。 使用@babel/plugin-syntax-dynamic-import123&#123; &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;]&#125; 配合Webpack、 @babel/preset-env使用在不支持Promise的环境，需要引入引入promise 和 iterator 的polyfills，使用core-js@3时： 123// src/main.jsimport &quot;core-js/modules/es.promise&quot;;import &quot;core-js/modules/es.array.iterator&quot;; 参考资料Dynamic Imports tc39/proposal-dynamic-import @babel/plugin-syntax-dynamic-import MDN-import","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"JS类型学习笔记","slug":"JS类型学习笔记","date":"2021-01-29T08:31:12.000Z","updated":"2021-02-18T03:15:09.768Z","comments":true,"path":"2021/01/29/JS类型学习笔记/","link":"","permalink":"https://www.blocknews.xyz/2021/01/29/JS类型学习笔记/","excerpt":"AtomGrammer Literal Variable Keywords Whitespace Line Terminator","text":"AtomGrammer Literal Variable Keywords Whitespace Line Terminator Runtime Types Execution Context Types Number String Boolean Object Null Undefined Symbol Number IEEE 754 Double Float Sign(1) Exponent(11) Fraction(52) Grammar DecimalLiteral 0 0. .2 1e3 BinaryIntegerLiteral 0b111 OctallIntegerLiteral 0o10 HexIntegerLiteral 0xFF 语法冲突： 0.toString() wrong 0 .toString right Number.MAX_SAFE_INTEGER：2**53 - 1 。 Number.MIN_SAFE_INTEGER： -(2**53 - 1)。 非整数的Number类型无法用==或===来比较,应该使用Number.EPSILON： 1234 console.log( 0.1 + 0.2 == 0.3); // falseconsole.log(Math.abs(0.1+0.2-0.3)&lt;Number.EPSILON) // true Number.EPSILON的值大概是2.2204460492503130808472633361816E-16`,或者 Math.pow(2, -52)。 String Character Code Point Encoding 字符集 ASCII Unicode UCS GB GB2312 GBK（GB13000） GB18030 ISO-8859 BIG5 Grammar “abc” ‘abc’ 1`abc` Template 1ab$&#123;x&#125;abc$&#123;y&#125;abc SymbolSymbol()的值是唯一的，主要用于作为对象的key，不能使用”new Symbol()“。 123let sym = Symbol('foo')Symbol('foo') === Symbol('foo') // falselet sym = new Symbol() // TypeError 可以使用Symbol.iterator自定义for … of 在对象上的行为： 1234567891011121314var o = new Objecto[Symbol.iterator] = function() &#123; var v = 0 return &#123; next: function() &#123; return &#123; value: v++, done: v &gt; 10 &#125; &#125; &#125; &#125;;for(var v of o) console.log(v); // 0 1 2 3 ... 9 Symbol.toPrimitive： 123456789101112131415161718192021var o = &#123; toString()&#123;return \"2\"&#125;, valueOf()&#123; return 1&#125;,&#125;var o2 = &#123; [Symbol.toPrimitive]()&#123; return 3&#125;, toString()&#123;return \"2\"&#125;, valueOf()&#123; return 1&#125;,&#125;var x=&#123;&#125;x[o]=1 // x[\"2\"]=1 toStringx[o2]=2 // x[3]=2 Symbol.toPrimitiveconsole.log(\"a\"+o) // a1 valueOfconsole.log(\"a\"+o2) // a3 Symbol.toPrimitiveconsole.log(x)// console.log(Math.abs(0.1+0.2-0.3)&lt;Number.EPSILON) Boolean true false Null &amp; Undefined+ null:是关键字，不能赋值 + undefined：不是关键字，可以赋值，容易引起错误 + void 0； Object设计对象的状态和行为时，应该遵循“行为改变状态”的原则。 Object in JavaScript原型当我们访问属性时，如果当前对象没有，则会沿着原型找原型对象是否有此名称的属性，而原型对象还可能有原型，形成了“原型链”。 属性 Key可以是String 或Symbol， 数据属性：用于描述状态 访问器属性：用于描述行为 Object API/Grammar {} [] Object.defineProperty Object.create、Object.setPrototypeOf、Object.getPrototypeOf new/class/extends new /function/prototype","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"《Babel插件手册》基础部分学习笔记","slug":"《Babel插件手册》基础部分学习笔记","date":"2021-01-28T10:02:30.000Z","updated":"2021-02-01T07:05:48.594Z","comments":true,"path":"2021/01/28/《Babel插件手册》基础部分学习笔记/","link":"","permalink":"https://www.blocknews.xyz/2021/01/28/《Babel插件手册》基础部分学习笔记/","excerpt":"介绍Babel是一个多用途JavaScript编译器。不仅如此，它还是一系列用于不同形式静态分析的模块集合。","text":"介绍Babel是一个多用途JavaScript编译器。不仅如此，它还是一系列用于不同形式静态分析的模块集合。 静态分析是在不执行代码的情况下对代码进行分析的过程。（执行代码的同时分析代码就是动态分析）静态分析的目的有很多。它可以用于代码检查，编译，代码高亮，代码转换，优化，压缩等等。 可以使用Babel构建许多提高效率写出更好程序的工具。 基础Babel是一个JavaScript编译器，尤其是一个source-to-source的编译器，通常又被称为转译器。这意味着你提供一些JavaScript代码给Babel，Babel修改并返回新的代码给你。 ASTs这些步骤都涉及到创建或者使用AST（Abstract Syntax Tree ）。AST由一个或者成百上千个Nodes组成。他们一起能够描述可用于静态分析的程序语法。 每个Node有如下接口： 123interface Node &#123; type: string;&#125; “type”字段是一个代表Node对象类型的字符串。（例如&quot;FunctionDeclaration&quot;, &quot;Identifier&quot;, or &quot;BinaryExpression&quot;)。每种类型的Node定义了一系列附加属性，用于描述该特定类型。 有一些附加属性是每个Node上都有的，Babel生成了这些属性用于描述Node在源码中的位置。 12345678910111213141516&#123; type: ..., start: 0, end: 38, loc: &#123; start: &#123; line: 1, column: 0 &#125;, end: &#123; line: 3, column: 1 &#125; &#125;, ...&#125; start, end, loc,这些属性每个Node上都有。 Babel的各个阶段Babel的三个主要阶段是parse，transform，generate。 ParseParse阶段接受代码输出AST。包括两个阶段： Lexical Analysis and Syntactic Analysis Lexical Analysis词法分析将一串代码转换为tokens流。 1n * n; 123456[ &#123; type: &#123; ... &#125;, value: \"n\", start: 0, end: 1, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: \"*\", start: 2, end: 3, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: \"n\", start: 4, end: 5, loc: &#123; ... &#125; &#125;, ...] 这里的每一个 type有一系列描述token的属性： 123456789101112131415161718ch of the types here have a set of properties describing the token:&#123; type: &#123; label: 'name', keyword: undefined, beforeExpr: false, startsExpr: true, rightAssociative: false, isLoop: false, isAssign: false, prefix: false, postfix: false, binop: null, updateContext: null &#125;, ...&#125; 和AST中的Nodes一样也有start, end, and loc. Syntactic Analysis语法分析将tokens流转换为AST。这个阶段利用tokens中的信息将它们重新格式化为AST，AST以一种更易于使用的方式来表示代码的结构。 TransformTransform阶段接受AST并遍历它，在遍历的过程中增加、更新、删除节点。目前为止，这是Babel或者其他任何编译器中最复杂的阶段。这是插件操作的地方，并且是这本手册的主题。所以我们现在不会太深入。 GenerateGenerate阶段将AST转换为code，同时生成source maps。 Traversal当你想转换AST时必须递归遍历树。 比如说 FunctionDeclaration这个类型。它有一些属性：id, params, and body。它们都有嵌套的节点。 1234567891011121314151617181920212223242526272829&#123; type: \"FunctionDeclaration\", id: &#123; type: \"Identifier\", name: \"square\" &#125;, params: [&#123; type: \"Identifier\", name: \"n\" &#125;], body: &#123; type: \"BlockStatement\", body: [&#123; type: \"ReturnStatement\", argument: &#123; type: \"BinaryExpression\", operator: \"*\", left: &#123; type: \"Identifier\", name: \"n\" &#125;, right: &#123; type: \"Identifier\", name: \"n\" &#125; &#125; &#125;] &#125;&#125; Visitors当我们说”going”一个节点，实际上指的是访问它们。这里使用了visitor pattern.访问者模式在不同语言的AST遍历中都有使用。简而言之，Visitors是对象，这个对象中定义了接收树中特殊节点的方法。如下： 12345678910const MyVisitor = &#123; Identifier() &#123; console.log(\"Called!\"); &#125;&#125;;// You can also create a visitor and add methods on it laterlet visitor = &#123;&#125;;visitor.MemberExpression = function() &#123;&#125;;visitor.FunctionDeclaration = function() &#123;&#125; 在下面的代码中， Identifier() 方法会被调用四次。 123function square(n) &#123; return n * n;&#125; 12345path.traverse(MyVisitor);Called!Called!Called!Called! 以上是在进入node的时候被调用的，也可以在离开node时被调用。 有如下树形结构： 12345678- FunctionDeclaration - Identifier (id) - Identifier (params[0]) - BlockStatement (body) - ReturnStatement (body) - BinaryExpression (argument) - Identifier (left) - Identifier (right) 遍历上面这棵树： Enter FunctionDeclaration Enter Identifier (id) Hit dead end Exit Identifier (id) Enter Identifier (params[0]) Hit dead end Exit Identifier (params[0]) Enter BlockStatement (body) Enter ReturnStatement (body) Enter BinaryExpression (argument) Enter Identifier (left) Hit dead end Exit Identifier (left) Enter Identifier (right) Hit dead end Exit Identifier (right) Exit BinaryExpression (argument) Exit ReturnStatement (body) Exit BlockStatement (body) Exit FunctionDeclaration 因此当创建一个visitor的时候有两次机会访问一个node。 12345678910const MyVisitor = &#123; Identifier: &#123; enter() &#123; console.log(\"Entered!\"); &#125;, exit() &#123; console.log(\"Exited!\"); &#125; &#125;&#125;; 使用 | 或别名，同一个方法可以作用于多种类型的节点： 123const MyVisitor = &#123; \"ExportNamedDeclaration|Flow\"(path) &#123;&#125;&#125;; Function是FunctionDeclaration, FunctionExpression, ArrowFunctionExpression, ObjectMethod and ClassMethod的别名： 123const MyVisitor = &#123; Function(path) &#123;&#125;&#125;; PathsAST中有许多Nodes，但是Nodes之间如何关联起来呢？我们可以使用Path，Path是一个呈现两个节点之间的关联的对象。 例如有如下节点和它的子节点： 12345678&#123; type: \"FunctionDeclaration\", id: &#123; type: \"Identifier\", name: \"square\" &#125;, ...&#125; 它的子节点Identifier 用path表示如下： 1234567891011&#123; \"parent\": &#123; \"type\": \"FunctionDeclaration\", \"id\": &#123;...&#125;, .... &#125;, \"node\": &#123; \"type\": \"Identifier\", \"name\": \"square\" &#125;&#125; Path还有其他元数据： 1234567891011121314151617181920212223&#123; \"parent\": &#123;...&#125;, \"node\": &#123;...&#125;, \"hub\": &#123;...&#125;, \"contexts\": [], \"data\": &#123;&#125;, \"shouldSkip\": false, \"shouldStop\": false, \"removed\": false, \"state\": null, \"opts\": null, \"skipKeys\": null, \"parentPath\": null, \"context\": null, \"container\": null, \"listKey\": null, \"inList\": false, \"parentKey\": null, \"key\": null, \"scope\": null, \"type\": null, \"typeAnnotation\": null&#125; 还有很多新增、更新、移动、移除节点的方法，后续会讨论。 某种意义上，paths是一个节点在树中的位置及各种相关信息的响应式呈现。当你调用了一个方法修改了树，相关的信息会更新。Babel帮你管理这一切更新，从而让使用node变得更容易并且尽可能无状态。 Paths in Visitors当你有一个Identifier()方法的visitor，你实际上是在访问path而不是node。 with the reactive representation of a node instead of the node itself. 12345const MyVisitor = &#123; Identifier(path) &#123; console.log(\"Visiting: \" + path.node.name); &#125;&#125;; 1a + b + c; 1234path.traverse(MyVisitor);Visiting: aVisiting: bVisiting: c StateState是AST转换的敌人。 例如如下代码: 123function square(n) &#123; return n * n;&#125; 写一个重新命名的visitor，将 n 转换为 x. 123456789101112131415let paramName;const MyVisitor = &#123; FunctionDeclaration(path) &#123; const param = path.node.params[0]; paramName = param.name; param.name = &quot;x&quot;; &#125;, Identifier(path) &#123; if (path.node.name === paramName) &#123; path.node.name = &quot;x&quot;; &#125; &#125;&#125;; 这对上面的例子有效，但是对于下面的代码就不对了： 1234function square(n) &#123; return n * n;&#125;n; 更好的处理方式是递归： 12345678910111213141516171819const updateParamNameVisitor = &#123; Identifier(path) &#123; if (path.node.name === this.paramName) &#123; path.node.name = &quot;x&quot;; &#125; &#125;&#125;;const MyVisitor = &#123; FunctionDeclaration(path) &#123; const param = path.node.params[0]; const paramName = param.name; param.name = &quot;x&quot;; path.traverse(updateParamNameVisitor, &#123; paramName &#125;); &#125;&#125;;path.traverse(MyVisitor); 这个例子证明了如何消除全局状态。 ScopesJavaScript 有 lexical scoping：123456789// global scopefunction scopeOne() &#123; // scope 1 function scopeTwo() &#123; // scope 2 &#125;&#125; 当我们转换代码时，需要小心作用域。我们需要确保修改代码的时候不会破坏已有的结构。 scope 可用如下形式表示： 1234567&#123; path: path, block: path.node, parentBlock: path.parent, parent: parentScope, bindings: [...]&#125; Bindings引用都属于特定的作用域，这种关系称之为bingding. 123456789function scopeOnce() &#123; var ref = \"This is a binding\"; ref; // This is a reference to a binding function scopeTwo() &#123; ref; // This is a reference to a binding from a lower scope &#125;&#125; 一个bingding看起来像这样： 12345678910111213&#123; identifier: node, scope: scope, path: path, kind: &apos;var&apos;, referenced: true, references: 3, referencePaths: [path, path, path], constant: false, constantViolations: [path]&#125;","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"Proxy与双向绑定","slug":"proxy与双向绑定","date":"2021-01-25T02:40:34.000Z","updated":"2021-02-01T04:06:24.933Z","comments":true,"path":"2021/01/25/proxy与双向绑定/","link":"","permalink":"https://www.blocknews.xyz/2021/01/25/proxy与双向绑定/","excerpt":"1 Proxy基础1.1 创建Proxy The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.","text":"1 Proxy基础1.1 创建Proxy The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object. Proxy由两个参数创建： target：被代理的原始对象 handler：一个定义哪些操作会被拦截和重新定义的对象 每个handler可以包含零个或多个捕获器,每个捕获器都对应一种基本操作,可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时,代理可以在这些操作传播到目标对象之前先调用捕获器函数,从而拦截并修改相应的行为。 12345678910111213141516171819202122232425const target = &#123; a: \"hehe\", b: \"haha\"&#125;;const handler = &#123; get: function(target, prop, receiver) &#123; return \"proxied: \"+target[prop]; &#125;, set:function(target,prop,value)&#123; if(prop in target)&#123; target[prop]=value &#125;else&#123; target[prop] = \"new prop\" &#125; return true &#125;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.a) //proxied: heheproxy.b = 123proxy.c =3console.log(\"proxy\",proxy) //&#123; a: 'hehe', b: 123, c: 'new prop' &#125; 1.2 Reflect Reflect is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of proxy handlers. Reflect is not a function object, so it’s not constructible. 在Proxy中使用： 1234567891011121314const target = &#123; a: \"hehe\", b: \"haha\"&#125;;const handler = &#123; get: function(target, prop, receiver) &#123; return Reflect.get(target, prop, receiver) &#125;&#125;;const proxy2 = new Proxy(target, handler);console.log(proxy2.a) 返回对象的own keys： 123456const target = &#123; a: &quot;hehe&quot;, b: &quot;haha&quot;&#125;;Reflect.ownKeys(target);// [ &quot;a&quot;, &quot;b&quot; ] 1.3 可撤销代理1234567891011121314var revocable = Proxy.revocable(&#123;&#125;, &#123; get: function(target, name) &#123; return \"[[\" + name + \"]]\"; &#125;&#125;);var proxy = revocable.proxy;console.log(proxy.foo); // \"[[foo]]\"revocable.revoke();console.log(proxy.foo); // TypeError is thrownproxy.foo = 1 // TypeError againdelete proxy.foo; // still TypeErrortypeof proxy // \"object\", typeof doesn't trigger any trap 2 Proxy 应用2.1 双向绑定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;label for=\"price\"&gt;price:&lt;/label&gt;&lt;input id=\"price\" /&gt;&lt;label for=\"quantity\"&gt;quantity:&lt;/label&gt;&lt;input id=\"quantity\" /&gt;&lt;label for=\"total\"&gt;total:&lt;/label&gt;&lt;input id=\"total\" disabled /&gt;&lt;script&gt;let targetMap = new WeakMap();let usedReactivities = [];let effect = function(callback)&#123; usedReactivities=[] callback() for(let [target,prop] of usedReactivities)&#123; track(target,prop,callback) &#125;&#125;let track=function(target,prop,effect)&#123; if(!targetMap.has(target))&#123; targetMap.set(target,new Map()); &#125; if(!targetMap.get(target).has(prop))&#123; targetMap.get(target).set(prop,new Set()); &#125; let deps = targetMap.get(target).get(prop); deps.add(effect)&#125;let trigger=function(target,prop)&#123; if(!targetMap.has(target)||!targetMap.get(target).has(prop))&#123; return &#125; let deps = targetMap.get(target).get(prop); for(let effect of deps)&#123; effect() &#125;&#125;let handler = &#123; get:function(target,prop)&#123; usedReactivities.push([target,prop]) return Reflect.get(target,prop) &#125;, set:function(target,prop,value)&#123; target[prop] =value trigger(target,prop) return true &#125;,&#125;let product = &#123; price:5, quantity:2&#125;let total = 0;let proxyProduct =new Proxy(product,handler)let priceDom = document.getElementById(\"price\")let quantityDom = document.getElementById(\"quantity\")let totalDom = document.getElementById(\"total\")priceDom.addEventListener('input',event=&gt;&#123; proxyProduct.price= event.target.value&#125;)quantityDom.addEventListener('input',event=&gt;&#123; proxyProduct.quantity= event.target.value&#125;)effect(()=&gt;&#123; priceDom.value=proxyProduct.price&#125;)effect(()=&gt;&#123; quantityDom.value=proxyProduct.quantity&#125;)effect(()=&gt;&#123; console.log(\"effect callback start \",total) total = proxyProduct.price*proxyProduct.quantity totalDom.value=total console.log(\"effect callback end\",total)&#125;)&lt;/script&gt; codepen 2.2 案例：调色板codepen 参考资料Proxy-MDN Meta programming-MDN Reactivity in Depth Vue3 Reactivity","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"Tree Shaking 学习笔记","slug":"Tree Shaking 学习笔记","date":"2021-01-19T02:05:30.000Z","updated":"2021-02-01T09:29:30.671Z","comments":true,"path":"2021/01/19/Tree Shaking 学习笔记/","link":"","permalink":"https://www.blocknews.xyz/2021/01/19/Tree Shaking 学习笔记/","excerpt":"1. Tree Shaking 必备理论1.1 Tree Shaking 为什么要依赖ESM规范","text":"1. Tree Shaking 必备理论1.1 Tree Shaking 为什么要依赖ESM规范 ESM特点： import 模块名只能是字符串常量 import 一般只能在模块的最顶层出现 import binding 是immutable 的 Tree Shaking 是在编译时进行无用代码消除，ESM具有静态分析能力。CommonJS只有在执行代码后才能动态确定依赖模块，不具备Tree Shaking的条件。 1.2 sideEffects A “side effect” is defined as code that performs a special behavior when imported, other than exposing one or more exports. An example of this are polyfills, which affect the global scope and usually do not provide an export. 具有副作用的模块难以被Tree Shaking 优化，Webpack 可以利用package.json 的side Effects属性来说明哪些模块具有副作用，剩余没有副作用的模块则可以被Tree Shaking优化. “sideEffects”为false表示全部代码均无副作用，可以安全地删除未用到的export导出： 1234&#123; \"name\": \"your-project\", \"sideEffects\": false&#125; 通过数组表示，./src/some-side-effectful-file.js和所有.css文件模块都有副作用。对于 Webpack 工具，还可以在module.rule配置中声明副作用模块。 1234567&#123; \"name\": \"your-project\", \"sideEffects\": [ \"./src/some-side-effectful-file.js\"， \"*.css\" ]&#125; 2. Tree Shaking 友好的导出模式2.1 不友好的导出模式： 导出一个包含多项属性和方法的对象 导出一个包含多项属性和方法的class 使用export default 导出 Webpack 和Rollup通常只处理函数和顶层的import/export 变量，不能把没用到的类或对象内部的方法消除掉。即便有插件（例如webpack-deep-scope-plugin ）或新版本支持，都增加了不必要的成本。 2.2 友好的导出模式：原子化和颗粒化导出： 123456export function add(a, b) &#123; return a + b&#125;export function subtract(a, b) &#123; return a - b&#125; 3. 前端工程生态和 Tree Shaking 实践3.1 Babel 和 Tree ShakingBabel 默认会将 ESM 编译为 CommonJS ,需要更改Babel配置。但是如果不使用CommonJS，基于Node.js的Jest会有问题，解决办法是不同环境采用不同的Babel配置，prodution环境： 1234567891011production: &#123; presets: [ [ '@babel/preset-env', &#123; modules: false &#125; ] ] &#125;,&#125; 在测试环境中： 1234567891011test: &#123; presets: [ [ '@babel/preset-env', &#123; modules: 'commonjs &#125; ] ] &#125;,&#125; 但是一些第三方模块代码为了方便进行 Tree Shaking，暴露出符合 ESM 模块的代码，对于这些模块，比如 Library1、Library2，我们还需要进行处理，这时候需要配置 Jest： 12345678910111213const path = require('path')const librariesToRecompile = [ 'Library1', 'Library2'].join('|')const config = &#123; transformIgnorePatterns: [ `[\\\\/]node_modules[\\\\/](?!($&#123;librariesToRecompile&#125;)).*$` ], transform: &#123; '^.+\\.jsx?$': path.resolve(__dirname, 'transformer.js') &#125;&#125; transformIgnorePatterns是 Jest 的一个配置项，默认值为node_modules，它表示：node_modules中的第三方模块代码，都不需要经过babel-jest编译。因此，我们自定义 transformIgnorePatterns的值为一个包含了 Library1、Library2 的正则表达式即可。 3.2 Webpack 和 Tree ShakingWebpack4.0 以上版本在 mode 为 production 时，会自动开启 Tree Shaking 能力。 4. 如何设计一个兼顾Tree Shaking 和易用性的公共库在package.json中，mian字段暴露CommonJS 模块，module字段暴露ESM。当require(&#39;Library&#39;)时，Webpack 会找到：dist/index.cjs.js；当import Library from &#39;Library&#39;时，Webpack 会找到：dist/index.esm.js。 123456// package.json&#123; \"name\": \"Library\", \"main\": \"dist/index.cjs.js\", \"module\": \"dist/index.esm.js\",&#125; 5. CSS 和Tree ShakingCSS 的 Tree Shaking 要在样式表中，找出没有被应用到选择器样式，进行删除。可以通过 PostCSS 插件对 CSS 对应的 AST 进行操作，达到 Tree Shaking 的目的， purgecss-webpack-plugin。 参考资料 Tree Shaking 《你的 Tree-Shaking 并没什么卵用》 Tree Shaking：移除 JavaScript 上下文中的未引用代码 How I fixed webpack tree shaking in 3 easy steps Reduce JavaScript Payloads with Tree Shaking postcss","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"JavaScript中的继承","slug":"JavaScript中的继承","date":"2021-01-17T06:03:12.000Z","updated":"2021-02-18T03:13:37.318Z","comments":true,"path":"2021/01/17/JavaScript中的继承/","link":"","permalink":"https://www.blocknews.xyz/2021/01/17/JavaScript中的继承/","excerpt":"JavaScript中实现继承的几种常见模式。","text":"JavaScript中实现继承的几种常见模式。 1、原型链12345678910111213141516171819function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subProperty = false&#125;SubType.prototype = new SuperType()SubType.prototype.getSubValue = function()&#123; return this.subProperty&#125;let instance = new SubType() 原型链的问题：原型中包含的引用值会在所有实例之间共享；子类型在实例化时不能给父类型的构造函数传参。 2、盗用构造函数（经典继承）12345678910function SuperType(name)&#123; this.name = name&#125;function SubType(name,age)&#123; SuperType.call(this,name) this.age = age&#125;let instance = new SubType('xiaoli','28') 3、组合继承12345678910111213141516function SuperType(name)&#123; this.name = name&#125;SuperType.prototype.say = function()&#123; console.log(\"hello\")&#125;function SubType(name,age)&#123; SuperType.call(this,name) this.age = age&#125;SubType.prototype = new SuperType()let instance = new SubType('xiaoliu','22')console.log('instance',instance)instance.say() 4、扩展：组合优于继承，利用Object.assign实现组合 Master the JavaScript Interview: What’s the Difference Between Class &amp; Prototypal Inheritance? 12345678910111213141516171819202122// Composition Example// http://codepen.io/ericelliott/pen/XXzadQ?editors=001// https://gist.github.com/ericelliott/fed0fd7a0d3388b06402const distortion = &#123; distortion: 1 &#125;;const volume = &#123; volume: 1 &#125;;const cabinet = &#123; cabinet: &apos;maple&apos; &#125;;const lowCut = &#123; lowCut: 1 &#125;;const inputLevel = &#123; inputLevel: 1 &#125;;const GuitarAmp = (options) =&gt; &#123; return Object.assign(&#123;&#125;, distortion, volume, cabinet, options);&#125;;const BassAmp = (options) =&gt; &#123; return Object.assign(&#123;&#125;, lowCut, volume, cabinet, options);&#125;;const ChannelStrip = (options) =&gt; &#123; return Object.assign(&#123;&#125;, inputLevel, lowCut, volume, options);&#125;;","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"Webpack Dev Server常用配置","slug":"Webpack-Dev-Server常用配置","date":"2019-03-09T10:52:11.000Z","updated":"2021-02-02T05:41:11.332Z","comments":true,"path":"2019/03/09/Webpack-Dev-Server常用配置/","link":"","permalink":"https://www.blocknews.xyz/2019/03/09/Webpack-Dev-Server常用配置/","excerpt":"webpack-dev-server 提供静态资源访问、Proxy代理、热模块更换等提高开发效率的功能。","text":"webpack-dev-server 提供静态资源访问、Proxy代理、热模块更换等提高开发效率的功能。 静态资源访问1234567// ./webpack.config.jsmodule.exports = &#123; // ... devServer: &#123; contentBase: 'public' &#125;&#125; Proxy 代理本地开发时访问服务端接口会遇到跨越的问题，可以通过设置CORS或代理解决，代理设置如下http://localhost:8080/swapi/api/people/1/ =&gt; https://swapi.dev/api/people/1/ : 123456789101112131415// ./webpack.config.jsmodule.exports = &#123; // ... devServer: &#123; proxy: &#123; '/swapi':&#123; target:'https://swapi.dev', pathRewrite:&#123; '^/swapi': '' &#125;, changeOrigin: true &#125; &#125; &#125;&#125; 添加响应头123456789// ./webpack.config.jsmodule.exports = &#123; //... devServer: &#123; headers: &#123; 'X-Custom-Foo': 'bar' &#125; &#125;&#125;; lazy模式lazy模式下只会在资源被请求时才会编译，此时不会监听文件变化 ，lazy模式下watchOptions无效。 123456module.exports = &#123; //... devServer: &#123; lazy: true &#125;&#125;; 热模块更换需要webpack.HotModuleReplacementPlugin才能完全启用HMR。 如果使用–hot选项启动webpack或webpack-dev-server，则会自动添加此插件。 123456module.exports = &#123; //... devServer: &#123; hot: true &#125;&#125;;","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"[译]什么是promise?","slug":"[译]什么是promise","date":"2019-02-04T03:58:39.000Z","updated":"2021-02-01T04:01:50.189Z","comments":true,"path":"2019/02/04/[译]什么是promise/","link":"","permalink":"https://www.blocknews.xyz/2019/02/04/[译]什么是promise/","excerpt":"Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。","text":"Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。 原文链接： Master the JavaScript Interview: What is a Promise?原文作者：Eric Elliott译者：SilentZhou Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。 什么是Promise?Promises是立刻执行的，意味着promise的构造函数一旦被调用它会立刻开始执行任何你给的任务。如果你需要懒执行,可以看看observables 或者tasks。 一个不完整的Promises历史Promises和futures(相似的概念)的早期实现于1980年代在MultiLisp和Concurrent Prolog这样的语言中出现的。“promise”这个词的使用最早是由 Barbara Liskov 和 Liuba Shrira 于1988年创造的。 我第一次在JavaScript中听说Promises的时候,Node还是一个全新的(事物),社区正在讨论处理异步行为的最佳方式。社区尝试过使用一段时间promises,但是最终选择了Node标准的错误优先回调。 与此同时,Dojo通过递延API添加了promises。(对promise的)兴趣和活动日益增长最终促使为了增加不同promise实现的互操作性的Promises/A规范的形成。 jQuery的异步操作基于promises进行了重构。jQuery的promise和Dojo的Deferred非常相似，由于jQuery一度非常流行它迅速成为最普遍使用的promise实现。然而，它不支持人们希望指望在其之上构建工具的两状态(执行态/拒绝态)链式调用和意外处理(https://blog.domenic.me/youre-missing-the-point-of-promises/)。。) 除了这些缺陷，jQuery正式让JavaScript promises成为主流，与此同时，更好的独立promise库例如Q和Bluebird变得非常流行。jQuery的promise实现的不兼容性激发了promise规范进行一些重要的澄清，promise因此被重写并被重新命名位Promise/A+规范。 ES6带来了兼容Promise/A+规范的全局Promise,其中一些非常重要的APIs建立在新标准Promise支持之上:特别是WHATWG Fetch规范和Async Functions标准(写作此文时处于阶段3草案)。 这里描述的是兼容Promise/A+规范,专注于ECMAScript标准实现的promises。 Promises是如何运行的Promise是一个能够同步返回异步函数的对象。它可能处于这三种状态之一： 执行态：onFulfilled()将会被调用(例如,resolve()被调用后) 拒绝态: onRejected())将会被调用(例如,reject()被调用后) 等待态: 还没有执行或拒绝 Promise如果没有处于等待(已经resolved或者rejected)那么就解决了。有时候人们使用resolved和settled表示同一件事：没有处于等待。 一旦解决,promise不能重新被解决。再次调用resolve()和reject()不会有效果。解决后promise的不可变性是一个重要特征。 原生JavaScript的promise不会暴露promise状态。相反,你最好把promise当作一个黑盒子。只有负责创建promise的函数才了解promise的状态，并有解决和拒绝的权限。 这是一个返回了promise的函数，返回的promise将在固定时间的延迟后解决： 123const wait = time =&gt; new Promise((resolve) =&gt; setTimeout(resolve, time));wait(3000).then(() =&gt; console.log('Hello!')); // 'Hello!' wait(3000)这个调用将在等待3000ms(3秒),然后打印Hello!。所有兼容规范的promise的都定义了一个.then()方法，该方法用于传递处理函数，处理函数可以接受解决值或拒绝值。 ES6的promise构造函数接受一个函数。该函数有两个参数，resolve()和reject()。在上面的例子中，我们只使用了resolve()，所以我们忽略了reject()。然后我们调用setTimeout()来形成延迟，然后当它结束时调用resolve()。 你可以将值传入resolve()或reject()，返回值将被传递到.then()方法的回调函数中。 当我使用reject()时，我总会传入一个Error对象。通常我希望有两种可能的解决状态：一种是正常的愉快之路，一种是例外——任何阻碍正常的愉快之路的情况。传入一个Error对象使情况更加明确。 重要的Promise规则Promise标准是由Promises/A+社区规范定义的。有许多遵照这个标准的实现，包括JavaScript标准的ECMAScript promises。 遵照规范的promises应该遵守一系列规则： promise或者thenable是一个提供了符合标准的.then()方法的对象。 等待态promise可以转变为执行或拒绝的状态。 一个执行态或拒绝态是已解决的，不能再转变为其它状态。 promise一旦解决，它必须有一个值(可以是undefined)。 这是所说的改变是用===来比较的。完成值可以是对象，对象的属性允许改变。 每一个promise必须提供一个具有以下特征的.then()方法： promise.then(onFulfilled?: Function,onRejected?: Function) =&gt; Promise .then()方法必须遵照以下规则： onFulfilled()和onRejected()都是可选参数。 如果提供的参数不是函数，则必须被忽略。 onFulfilled()将会在promise被执行后调用，promise的值将作为第一个参数。 onRejected()将会在promise被拒绝后调用，拒绝的理由将作为第一个参数。理由可以是任意的有效JavaScript值，但是因为拒绝本质上就是异常，我推荐使用Error对象。 onFulfilled()和onRejected()都只能最多被调用一次。 同一个promise可能调用多次.then()。换言之，promise可以被用来汇总回调函数。 .then()方法必须返回一个新的promise:promise2。 如果onFulfilled()或onRejected()有一个返回值x，并且x是一个promise，promise2将锁定为x(假定与x有相同的状态和值)。否则,promise2将被执行且值是x。 如果onFulfilled()或onRejected()抛出一个异常e,promise2必须以e作为理由被拒绝。 如果onFulfilled()不是一个函数并且promise1已经被执行，promise2则必须以同promise1相同的值被执行。 如果onRejected()不是一个函数并且promise1已经被拒绝，promise2则必须以同promise1相同的理由被拒绝。 Promise链因为.then()总是返回一个新的promise，那么精确控制如何处理和在什么地方处理错误链式调用Promise。Promises允许你模仿同步代码的try/catch行为。 和同步代码一样，链式调用会形成顺序执行。换言之，你可以这样做： fetch(url).then(process).then(save).catch(handleErrors); 假设每一个函数,fetch(),process(),和save()都返回promises, process()将等待fetch()完成再开始,save()将等待process()完成再开始。handleErrors()只会当前面任意一个promise拒绝时才执行。 这是一个多次拒绝的复杂promise链的例子： 123456789101112131415161718192021222324252627282930313233343536const wait = time =&gt; new Promise( res =&gt; setTimeout(() =&gt; res(), time));wait(200) // onFulfilled() can return a new promise, `x` .then(() =&gt; new Promise(res =&gt; res('foo'))) // the next promise will assume the state of `x` .then(a =&gt; a) // Above we returned the unwrapped value of `x` // so `.then()` above returns a fulfilled promise // with that value: .then(b =&gt; console.log(b)) // 'foo' // Note that `null` is a valid promise value: .then(() =&gt; null) .then(c =&gt; console.log(c)) // null // The following error is not reported yet: .then(() =&gt; &#123;throw new Error('foo');&#125;) // Instead, the returned promise is rejected // with the error as the reason: .then( // Nothing is logged here due to the error above: d =&gt; console.log(`d: $&#123; d &#125;`), // Now we handle the error (rejection reason) e =&gt; console.log(e)) // [Error: foo] // With the previous exception handled, we can continue: .then(f =&gt; console.log(`f: $&#123; f &#125;`)) // f: undefined // The following doesn't log. e was already handled, // so this handler doesn't get called: .catch(e =&gt; console.log(e)) .then(() =&gt; &#123; throw new Error('bar'); &#125;) // When a promise is rejected, success handlers get skipped. // Nothing logs here because of the 'bar' exception: .then(g =&gt; console.log(`g: $&#123; g &#125;`)) .catch(h =&gt; console.log(h)) // [Error: bar]; 错误处理请注意promises同时具有成功和错误处理函数，很容易见到下面这样的代码： save().then(handleSuccess,handleError); 但是如果handleSuccess()抛出了错误该怎么办?从.then()返回的promise会被拒绝，但是没办法捕捉到这个拒绝——意味着一个错误在你的app中被吞没了。天哪！ 因为这个原因，一些人认为上面的代码是反模式的，并且推荐下面的写法： save().then(handleSuccess).catch(handleError); 其中的区别是微妙但重要的。在第一个例子中，源自save()操作的错误将被捕获，但是源自handleSuccess()函数的错误将被吞没。 在第二个例子中，.catch()将会处理来自save()或handleSuccess()的拒绝。 当然，save()错误可能是网络错误，而handleSuccess()错误可能是因为开发者忘记处理特定的状态码。如果你想以不同方式处理他们呢?你可以选择同时处理他们： save().then(handleSuccess,handleNetworkError) .catch(handleProgrammerError); 无论你喜欢哪种方式，我建议在所有promise链的末尾加上.catch()。值得重复一遍： 我建议在所有promise链的末尾加上.catch()。 我如何取消一个promise？Promise的新用户经常想知道的第一件事是如何取消一个promise。这有个主意：只需要以取消为理由拒绝这个promise。如果你需要以不同于寻常错误的方式来处理它，那么你可以在你的错误处理程序中新建一个分支。 这里是一些人们取消promise时犯的常见错误： 在promise上添加.cancel()添加.cancel()让promise变得不合标准，而且同时也打破了另一条promise的规则：只有创建promise的函数才能够解决，拒绝，取消promise。暴露它破坏了封装性，并且鼓励人们在他们不应该知道的地方编写操作promise的代码。应该避免面条代码和破坏promise。 忘记清除一些聪明人已经明白有办法利用Promise.race()作为取消机制。这里的问题是取消控制在创建promise的函数中进行，这个函数是唯一可以进行适当清理活动的地方，例如清除超时或者通过清除对数据的引用来释放内存，等等… 忘记处理被拒绝的取消promise你知道当你忘记处理被拒绝的promise时Chrome会一直在控制台发出警告消息吗？天哪！ 过于复杂撤销的TC39提案提出了一个单独的消息通道用于取消。它使用了一个称作取消令牌的新概念。在我看来，这个方案会让promise规范变得相当臃肿。它提供的原有规范不支持的唯一特征是拒绝和取消的分离，但在我看来，这是一开始就没必要的。 你想根据是否有异常或取消来切换处理方式吗？是的，当然。但这是promise的工作吗？在我看来,不，它不是。 重新思考promise的取消通常，我会在promise创建时传入所有promise决定如何解决/拒绝/取消所需要的信息。那样的话，promise不需要一个.cancel()方法。你可能奇怪如何在promise创建时就知道是否需要取消。 “如果我不确定是否要取消，我怎么知道在promise创建时传入什么？” 如果存在一种对象可以代表未来的一个值… oh，等等。 我们传入的代表是否取消的值自身也可以是一个promise。它看起来可能是这样的： 1234567891011121314151617181920const wait = ( time, cancel = Promise.reject()) =&gt; new Promise((resolve, reject) =&gt; &#123; const timer = setTimeout(resolve, time); const noop = () =&gt; &#123;&#125;; cancel.then(() =&gt; &#123; clearTimeout(timer); reject(new Error('Cancelled')); &#125;, noop);&#125;);const shouldCancel = Promise.resolve(); // Yes, cancel// const shouldCancel = Promise.reject(); // No cancelwait(2000, shouldCancel).then( () =&gt; console.log('Hello!'), (e) =&gt; console.log(e) // [Error: Cancelled]); 我们使用默认参数使它默认不取消。它使cancel参数变成方便的可选参数。然后我们像之前一样设置超时，但是这次我们保存了超时计时的ID以便之后清除。 我们使用cancel.then()方法来处理取消和资源清理。这个方法只会在promise有机会解决之前被取消时才会运行。如果你取消得太晚，你会错过机会。火车已经驶离站台了。 注意：你可能想知道noop()函数是干什么的。noop这个词的意思是空操作，意味着函数什么也不做。如果没有它，V8会抛出警告消息：UnhandledPromiseRejectionWarning: Unhandled promise rejection。始终处理promise拒绝是一个好主意，即使处理函数是一个noop()。 概括promise的取消这对于wait()计时器是很好的，但我们还可以进一步抽象出来封装所有你不得不记住的事： cancel promise的默认状态为拒绝——如果没有传入cancel promise，我们不想取消或出现错误。 当你拒绝取消时请记得执行清理。 请记住，onCancel清理时自身可能会产生错误，这个错误也需要处理。(请注意在上面的等待例子中错误处理被省略了——它很容易被忘记!) 让我们创建一个可以取消promise的基础工具，它可以用来包裹任何promise。例如，处理网络申请，等等…它看起来像这样： speculation(fn: SpecFunction, shouldCancel: Promise) =&gt; Promise SpecFunction就像你传入Promise构造函数的函数一样，只有一点不同——它有一个onCancel()处理函数： SpecFunction(resolve: Function, reject: Function, onCancel: Function) =&gt; Void 12345678910111213141516171819202122// HOF Wraps the native Promise API// to add take a shouldCancel promise and add// an onCancel() callback.const speculation = ( fn, cancel = Promise.reject() // Don't cancel by default) =&gt; new Promise((resolve, reject) =&gt; &#123; const noop = () =&gt; &#123;&#125;; const onCancel = ( handleCancel ) =&gt; cancel.then( handleCancel, // Ignore expected cancel rejections: noop ) // handle onCancel errors .catch(e =&gt; reject(e)) ; fn(resolve, reject, onCancel);&#125;); 请注意，这只是一个告诉你它工作原理的要点的例子。你还需要考虑许多其它边缘情况。例如，在这个例子中，如果你在promise已经解决后取消promise，handleCancel将会被调用。 我将这些边缘情况实现了一个在维护的生产版本作为开源库，Speculation。 让我们使用改进的库来重写可取消的wait()程序。首先安装speculation： npm install –save speculation 现在你可以引入并使用它： 12345678910111213141516171819202122232425import speculation from 'speculation';const wait = ( time, cancel = Promise.reject() // By default, don't cancel) =&gt; speculation((resolve, reject, onCancel) =&gt; &#123; const timer = setTimeout(resolve, time); // Use onCancel to clean up any lingering resources // and then call reject(). You can pass a custom reason. onCancel(() =&gt; &#123; clearTimeout(timer); reject(new Error('Cancelled')); &#125;);&#125;, cancel); // remember to pass in cancel!wait(200, wait(500)).then( () =&gt; console.log('Hello!'), (e) =&gt; console.log(e)); // 'Hello!'wait(200, wait(50)).then( () =&gt; console.log('Hello!'), (e) =&gt; console.log(e)); // [Error: Cancelled] 这样就简化了许多，因为你不需要担心noop(),在onCancel()中捕捉错误或者其它边缘情况。那些细节已经被speculation()提取出来了。看看这个，在真实项目中自由使用它吧。 原生JS Promise的额外内容原生Promise对象有一些你可能感兴趣的其它内容： Promise.reject()返回一个被拒绝的promise。 Promise.resolve()返回一个被解决的promise。 Promise.race()接受一个数组(或任何可迭代对象)，返回一个promise，这个promise将会在第一个解决promise之后以相同的值解决，或者在第一个拒绝的promise之后以相同的理由拒绝。 Promise.all()接受一个数组(或任何可迭代对象)，返回一个promise，这个promise将会在所有可迭代参数的promises解决之后解决，或者在第一个拒绝的promise之后以相同的理由拒绝。 结论Promises已经变成JavaScript中几个习惯用法的一部分，包括用于现代ajax请求的WHATWG Fetch标准，和用于让异步代码看起来像同步代码的Async Functions标准。 写这篇文章的时候Async functions处于第3阶段，但是我预计它们会很快变成JavaScript中一个流行的，常用的异步编程解决方案——意味着对于JavaScript开发者，学习领会promises将在不远的将来变得更加重要。 例如，如果你正在使用Redux,我建议你看看redux-saga:一个用于管理Redux中副作用的库,纵观文档它依赖于async functions。 我希望即使是有经验的promise使用者在阅读完本文后，对于什么是promise、promise的工作原理以及如何更好地使用promise能够有更好的了解。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"[译]什么是闭包?","slug":"译-什么是闭包","date":"2019-02-02T11:28:39.000Z","updated":"2021-02-18T03:24:17.467Z","comments":true,"path":"2019/02/02/译-什么是闭包/","link":"","permalink":"https://www.blocknews.xyz/2019/02/02/译-什么是闭包/","excerpt":"原文链接： Master the JavaScript Interview: What is a Closure?原文作者：Eric Elliott译者：SilentZhou 我将以我在JavaScript面试中经常问的第一个或最后一个问题来开始这一系列文章。坦白说，如果不了解闭包你在JavaScript的道路上是不会走得太远的。","text":"原文链接： Master the JavaScript Interview: What is a Closure?原文作者：Eric Elliott译者：SilentZhou 我将以我在JavaScript面试中经常问的第一个或最后一个问题来开始这一系列文章。坦白说，如果不了解闭包你在JavaScript的道路上是不会走得太远的。 你或许会鼓捣一点代码，但是你真的明白如何构建一个真正的JavaScript应用吗？你真的明白正在发生什么，或者说应用是如何运行的吗？我保持怀疑。不知道这个问题的答案就是一个严重的警示。 你不仅应该知道闭包的机制，而且应该知道为什么闭包很重要并能够轻松答出闭包的几个用途。 闭包经常在对象数据隐私、事件处理程序和回调函数、部分函数应用、柯里化和其它函数式编程模式中。 我不在乎被面试的人是否知道闭包这个词或者这个词的技术定义。我想知道他们是否了解基本机制。如果他们不知道，这通常是一个清晰的指标，说明开发者没有多少开发实际JavaScript应用的经验。 如果你不能回答这个问题，你就是一个初级开发者。我不在乎你编程多久了。 这也许听起来刻薄，但其实并不(刻薄)。我的意思是最称职的面试官会问你什么是闭包,通常回答错这个问题会让你失去这个工作。或者你幸运的得到了这个工作，也会让你每年损失潜在的数万美元薪水，因为无论你编程多久你将被雇佣为一个初级开发者而不是一个高级开发者。 准备好回答接下来的问题:”你能说出两个闭包的常见应用吗?” 什么是闭包？闭包是函数和对它词法环境的引用的结合。换言之,闭包让你能够从一个函数内部访问外部函数的作用域。在JavaScript中，每次创建函数时，都会在函数创建时形成闭包。 为了使用闭包,在一个函数中定义另一个函数并暴露这个函数就行了。要暴露一个函数，将其返回或者传递给另一个函数。 内部函数可以访问外部函数作用域内的变量，即使外部函数已经返回了。 闭包的使用 (案例)在其它语言中,闭包通常被用于给予对象数据隐私。数据隐私是一个帮助我们面向接口编程而不是面向实现的必要属性。这是一个帮助我们构建更健壮的软件的重要概念,因为实现细节相比接口更容易发生重大改变。 在JavaScript中，闭包是保证数据隐私的主要机制。当你为了数据隐私而使用闭包时,括号内变量只在外部函数的作用域中。你不能从作用域外获得数据除非通过对象的特权方法。在JavaScript中,任何在闭包范围内暴露的方法都是特权的(方法).例如: 1234567891011121314151617181920212223const getSecret = (secret) =&gt; &#123; return &#123; get: () =&gt; secret &#125;;&#125;;test('Closure for object privacy.', assert =&gt; &#123; const msg = '.get() should have access to the closure.'; const expected = 1; const obj = getSecret(1); const actual = obj.get(); try &#123; assert.ok(secret, 'This throws an error.'); &#125; catch (e) &#123; assert.ok(true, `The secret var is only available to privileged methods.`); &#125; assert.equal(actual, expected, msg); assert.end();&#125;); 在上面的例子中,定义在getSecret()作用域中的.get()方法成了一个特权方法，能够访问getSecret()中的任何变量。在这个例子中,就是参数secret. 对象不是产生数据隐私的唯一方法。闭包也能用于创建返回值受内部状态影响的有状态的函数,例如: const secret = msg =&gt; () =&gt; msg; 12345678910111213141516171819// Secret - creates closures with secret messages.// https://gist.github.com/ericelliott/f6a87bc41de31562d0f9// https://jsbin.com/hitusu/edit?html,js,output// secret(msg: String) =&gt; getSecret() =&gt; msg: Stringconst secret = (msg) =&gt; () =&gt; msg;test('secret', assert =&gt; &#123; const msg = 'secret() should return a function that returns the passed secret.'; const theSecret = 'Closures are easy.'; const mySecret = secret(theSecret); const actual = mySecret(); const expected = theSecret; assert.equal(actual, expected, msg); assert.end();&#125;); 在函数式编程中,闭包常被用于部分应用&amp;柯里化中。这里需要一些定义： 应用：将函数应用于其参数以生成返回值的过程。 部分应用：将函数应用于其部分参数的过程。部分应用函数被返回等待后续使用。换言之,一个函数，它接受一个带有多个参数的函数，并返回一个参数较少的函数。部分应用将一个或多个参数固定在返回的函数中,返回的函数为了完成函数应用接受剩下的参数作为参数。 部分应用利用闭包作用域来固定参数。你可以写一个能够部分应用参数到目标函数的通用函数。它将具有以下特征: partialApply(targetFunction: Function, …fixedArgs: Any[]) =&gt;functionWithFewerParams(…remainingArgs: Any[]) 如果在阅读上面的符号时需要帮助，查看Rtype: Reading Function Signatures(https://github.com/ericelliott/rtype#reading-function-signatures)。 它将接受一个以任意个数字作为参数的函数，随后是我们想部分应用于函数的参数,然后返回一个接受剩下的参数的函数。 一个例子或许有助于理解。比如说你有一个将两个数字相加的函数： const add = (a, b) =&gt; a + b; 现在你想要一个将10和任意数字相加的函数。我们称它add10()。add10(5)的结果将是15。我们的partialApply()函数能够完成这个操作： const add10 = partialApply(add, 10);add10(5); 在这个例子中,这个参数10变成了add10()闭包作用域中的一个固定参数。 让我们看一个partialApply()的可能实现: 123456789101112131415161718192021222324// Generic Partial Application Function// https://jsbin.com/biyupu/edit?html,js,output// https://gist.github.com/ericelliott/f0a8fd662111ea2f569e// partialApply(targetFunction: Function, ...fixedArgs: Any[]) =&gt;// functionWithFewerParams(...remainingArgs: Any[])const partialApply = (fn, ...fixedArgs) =&gt; &#123; return function (...remainingArgs) &#123; return fn.apply(this, fixedArgs.concat(remainingArgs)); &#125;;&#125;;test('add10', assert =&gt; &#123; const msg = 'partialApply() should partially apply functions' const add = (a, b) =&gt; a + b; const add10 = partialApply(add, 10); const actual = add10(5); const expected = 15; assert.equal(actual, expected, msg);&#125;); 正如你所见，它仅仅是返回了一个函数，该函数保留了传递给partialApply()函数的fixedArgs参数的访问权限。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"[译]什么是纯函数?","slug":"译-什么是纯函数","date":"2019-01-23T01:56:37.000Z","updated":"2019-01-23T09:03:40.000Z","comments":true,"path":"2019/01/23/译-什么是纯函数/","link":"","permalink":"https://www.blocknews.xyz/2019/01/23/译-什么是纯函数/","excerpt":"纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？","text":"纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？ 原文链接： Master the JavaScript Interview: What is a Pure Function?原文作者：Eric Elliott译者：SilentZhou 纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？ 通过一个免费课程 “Learn JavaScript with Eric Elliott”:我们能够回答这个问题。 在我们掌握什么是纯函数之前,让我们先仔细看看什么是函数。或许有一种让函数式编程更容易理解的方式来看待函数。 什么是函数？函数是一个获取输入,调用参数,输出返回值的过程。函数有以下用途： 映射：基于输入产生输出。函数使输入和输出之间产生映射关系。 程序：函数被调用以执行一系列步骤。执行顺序被称为过程,这种编程方式被称为过程程序设计。 I/O:一些函数被用于与系统的其它部分通信,例如屏幕,存储,系统日志或者网络。 映射纯函数都是映射。函数映射输入参数为返回值,意味着对于每一组输入,都有一个输出值。函数会获取输入然后返回相关的输出。 `Math.max()`以数字为参数返回其中最大值： Math.max(2, 8, 5); // 8 在这个例子中,2、8和5是参数。它们是被传入函数的值。 `Math.max()`是一个传入任意个数字然后返回其中最大值的函数。在这里,我们传入的最大数字是8,这就是返回的数字。 函数在计算和数学中真的非常重要。它们帮助我们以有用的方式处理数据。好的程序员会给函数一个描述性的函数名,当我们看代码的时候可以看函数名就可以了解这个函数是做什么的。 数学中也有函数,而且运行方式和javascript中的函数非常相似。你很可能在代数中见过函数。它们就像下面这样： f(x) = 2x 这意味着我们正在声明一个名为f的函数,这个函数接收一个参数x,然后将x乘以2. 要使用这个函数,我们只需要为x提过一个值： f(2) 在代数中,这个和下面写的是相同的： 4 因此你可以在任何地方将f(2)替换成4. 现在让我们将这个函数转换为javascript: const double = x =&gt; x * 2; 你可以用`console.log()`检查这个函数的输出： console.log( double(5) ); // 10 还记得我说过在数学函数中你可以用4替换f(2)吗？在这里,javascript引擎将double(5)替换成答案10. 因此, `console.log( double(5) );`和`console.log(10);`是一样的。 这是正确的，因为`double()`是一个纯函数，但是如果`double()`有副作用，例如存储值到硬盘或者记录到控制台，你没办法只替换`double(5)` 为10而不改变原函数的意义。 如果你想要引用透明性（referential transparency），你需要使用纯函数。 纯函数一个纯函数是一个这样的函数： 相同的输入，总会返回相同的输出。 不会产生副作用。 如果一个函数被调用时没有用到返回值也是有意义的，那绝对是一个不纯的函数。对于纯函数，那就是一个空语句。 我建议你偏爱纯函数。意思是，如果用纯函数实现一个程序需求是可行的，那就用纯函数而不是其他选项。纯函数获得一些输入然后重要的设计原则是KISS (Keep It Simple, Stupid).我喜欢让它愚蠢的简单。纯函数用最可行的方式保持愚蠢的简单。 纯函数有很多有益的属性，这些属性形成了函数式编程的基础。纯函数完全独立于外部状态，因此纯函数可以免于由于共享可变状态造成的漏洞。纯函数的独立性使它成为多cpu和分布式计算集群中并发编程的不错选择，使他们成为很多类型的科学和资源密集型计算任务的必要部分。 纯函数也非常独立-易于在代码中移动，重构和重新组织，使你的程序更灵活，能够适应未来的变化。 共享状态的麻烦几年前我正在做一个能够让用户搜索音乐家然后加载这个音乐家的音乐列表到web播放器上的app。当时Google Instant刚刚推出，它会在您输入搜索查询时显示即时搜索结果。基于Ajax的自动补全突然风行一时。 唯一的问题是用户输入经常比自动补全搜索响应快，这会造成一些奇怪的错误。它会触发竞态条件，更新的建议会被过时的建议替换掉。 为什么会发生这种情况？ AJAX成功时的处理函数能够直接更新用户看到的列表。最慢的AJAX请求总是能通过盲目替换结果来赢得用户的注意，甚至会替换掉更新的结果。 任何种类的异步操作或并发会造成相似的竞态条件。竞态条件会在输出依赖于不受控事件（例如网络、设备延迟、用户输入、随机性等等）的顺序时发生。事实上，如果你使用共享状态而状态依赖于根据不确定性因素而变化的顺序时，总而言之，输出无法预测，也就意味着不可能进行适当的测试或完全理解。正如Martin Odersky所说： 非确定性 = 并行处理 + 共享状态 程序确定性通常是计算中一个理想的特性。或许你觉得这不是问题因为javascript是单线程，因此不会有并行处理问题，但是正如AJAX这个例子说明的，一个单线程js引擎并不意味着没有并发。事实正相反，JavaScript中有很多种并发。API I/O, event listeners, web workers, iframes, and timeouts都会给你的程序带来不可预测性。把它们和共享状态结合，你就得到了很多的错误。 纯函数可以帮你避免这类错误。 给定相同的输入，始终返回相同的输出使用`double()`函数时，你可以用结果替换函数调用，程序是相同的 — 在你的程序中`double(5)`和 `10` 意味着同一件事，无论上下文如何、无论何时调用、无论调用多少次。 但是你不能说所有的函数都是如此。一些函数不仅仅依赖传入的参数来产生输出。 想一想下面这个例子： Math.random(); // =&gt; 0.4011148700956255 Math.random(); // =&gt; 0.8533405303023756 Math.random(); // =&gt; 0.3550692005082965 即使我们没有传入任何值到函数中，它们都产生了不同的输出，意味着`Math.random()`不是纯的。 `Math.random()`每次运行时会产生一个新的介于0到1之间的随机值，因此很明显你不能用0.4011148700956255替换掉它而不使程序的含义发生变化。 那样每次就会产生相同的结果。我们每次向计算机请求一个随机数的时候，通常意味着我们想得到一个不同于上一次的结果。如果一对骰子的每一面都印着相同的数字，那还有什么意义呢？ 有时候我们会向计算机询问现在的时间。我们不会深究这个函数的实现细节。现在，复制下面的代码： const time = () =&gt; new Date().toLocaleTimeString(); time(); // =&gt; &quot;5:15:45 PM&quot; 如果你用现在的时间替换掉`time()`会发生什么？ 它会说是总是相同的时间：这个函数被替换的时间。换言之，它一天只能产生一次正确的输出，只有当你在这个函数被替换的精确时刻运行这个程序才行。 很清楚，`time()`函数不像`double()` 函数。 一个函数只有当给定相同的输入产生相同的输出时才是纯函数。你可能记得这条从代数课上学到的规则：相同的输入值总是映射到相同的输出值。然而，许多输入值可能映射到相同的输出值。例如，下面的函数时纯函数： const highpass = (cutoff, value) =&gt; value &gt;= cutoff; 相同的输入值总是会映射到相同的输出值： highpass(5, 5); // =&gt; true highpass(5, 5); // =&gt; true highpass(5, 5); // =&gt; true 许多输入值总是会映射到相同的输出值： highpass(5, 123); // true highpass(5, 6); // true highpass(5, 18); // true highpass(5, 1); // false highpass(5, 3); // false highpass(5, 4); // false 一个纯函数必须不依赖任何外部可变状态，因为那样的话它将不再具有确定性和引用透明性。 纯函数不产生副作用一个纯函数不产生任何副作用，意味着它不能改变任何外部状态。 不可变性JavaScript的对象参数是引用传递，意味着如果一个函数修改了对象或数组参数的属性,这将改变在函数外部可访问的状态。 相想下面这个改变，不纯的`addToCart()`函数: // impure addToCart mutates existing cart const addToCart = (cart, item, quantity) =&gt; { cart.items.push({ item, quantity }); return cart; }; test(&apos;addToCart()&apos;, assert =&gt; { const msg = &apos;addToCart() should add a new item to the cart.&apos;; const originalCart = { items: [] }; const cart = addToCart( originalCart, { name: &quot;Digital SLR Camera&quot;, price: &apos;1495&apos; }, 1 ); const expected = 1; // num items in cart const actual = cart.items.length; assert.equal(actual, expected, msg); assert.deepEqual(originalCart, cart, &apos;mutates original cart.&apos;); assert.end(); }); 这个函数传入了一个购物车，一个被放入购物车的项目和项目数量，然后返回了项目被添加后的同一个购物车。 问题是我们修改了一些共享状态。在这个函数被调用之前，其它函数也许依赖于那个购物车对象的状态，现在我们既然修改了那个共享状态，如果我们改变函数的调用顺序就不得不担心会对程序逻辑造成什么影响。重构代码可能会导致出现错误，这会搞砸订单引起顾客的不满。 现在考虑下面这个版本： // Pure addToCart() returns a new cart // It does not mutate the original. const addToCart = (cart, item, quantity) =&gt; { const newCart = lodash.cloneDeep(cart); newCart.items.push({ item, quantity }); return newCart; }; test(&apos;addToCart()&apos;, assert =&gt; { const msg = &apos;addToCart() should add a new item to the cart.&apos;; const originalCart = { items: [] }; // deep-freeze on npm // throws an error if original is mutated deepFreeze(originalCart); const cart = addToCart( originalCart, { name: &quot;Digital SLR Camera&quot;, price: &apos;1495&apos; }, 1 ); const expected = 1; // num items in cart const actual = cart.items.length; assert.equal(actual, expected, msg); assert.notDeepEqual(originalCart, cart, &apos;should not mutate original cart.&apos;); assert.end(); }); 在这个例子中，有一个嵌套在对象中的数组，这也是为什么我使用了深拷贝。这是一个比你通常要处理的状态更复杂的状态。对于大多数情况，你可以将它分成更小的块。 例如，Redux让你组合reducers而不是在每个reducer中处理整个应用的状态。结果就是当你每次更新状态中的一小部分时，你不必深拷贝整个应用状态。相反，你可以使用非破坏性的数组方法或者`Object.assign()`来更新应用状态的一小部分。 轮到你了，修改“这个非纯函数”为纯函数。使它在不修改测试代码的情况下通过单元测试。","categories":[{"name":"technology","slug":"technology","permalink":"https://www.blocknews.xyz/categories/technology/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://www.blocknews.xyz/tags/programming/"}]},{"title":"我们还要再等30年吗?","slug":"我们还要再等30年吗","date":"2018-09-25T07:18:00.000Z","updated":"2019-01-23T09:03:42.000Z","comments":true,"path":"2018/09/25/我们还要再等30年吗/","link":"","permalink":"https://www.blocknews.xyz/2018/09/25/我们还要再等30年吗/","excerpt":"我是一个假乐迷。去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。","text":"我是一个假乐迷。去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。 我是一个假乐迷。 去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。然而，即使是他们的歌，我也谈不上非常熟悉。我勉强挤在外围，不敢太靠近舞台，靠近舞台的是一听前奏就开始摇头晃脑跟着哼唱的核心歌迷。其实我不常听歌，唱歌五音不全，喜欢他们的歌因为歌中表达的东西。","categories":[{"name":"life","slug":"life","permalink":"https://www.blocknews.xyz/categories/life/"}],"tags":[{"name":"music","slug":"music","permalink":"https://www.blocknews.xyz/tags/music/"}]}]}