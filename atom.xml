<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>缥缈孤鸿影</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.blocknews.xyz/"/>
  <updated>2021-02-01T07:05:48.594Z</updated>
  <id>https://www.blocknews.xyz/</id>
  
  <author>
    <name>SilentZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Babel插件手册》基础部分学习笔记</title>
    <link href="https://www.blocknews.xyz/2021/01/28/%E3%80%8ABabel%E6%8F%92%E4%BB%B6%E6%89%8B%E5%86%8C%E3%80%8B%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.blocknews.xyz/2021/01/28/《Babel插件手册》基础部分学习笔记/</id>
    <published>2021-01-28T10:02:30.000Z</published>
    <updated>2021-02-01T07:05:48.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Babel是一个多用途JavaScript编译器。不仅如此，它还是一系列用于不同形式静态分析的模块集合。</p><a id="more"></a><blockquote><p>静态分析是在不执行代码的情况下对代码进行分析的过程。（执行代码的同时分析代码就是动态分析）静态分析的目的有很多。它可以用于代码检查，编译，代码高亮，代码转换，优化，压缩等等。</p></blockquote><p>可以使用Babel构建许多提高效率写出更好程序的工具。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Babel是一个JavaScript编译器，尤其是一个source-to-source的编译器，通常又被称为转译器。这意味着你提供一些JavaScript代码给Babel，Babel修改并返回新的代码给你。</p><h2 id="ASTs"><a href="#ASTs" class="headerlink" title="ASTs"></a>ASTs</h2><p>这些步骤都涉及到创建或者使用AST（<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">Abstract Syntax Tree</a> ）。AST由一个或者成百上千个Nodes组成。他们一起能够描述可用于静态分析的程序语法。</p><p>每个Node有如下接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Node &#123;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“type”字段是一个代表Node对象类型的字符串。（例如<code>&quot;FunctionDeclaration&quot;</code>, <code>&quot;Identifier&quot;</code>, or <code>&quot;BinaryExpression&quot;</code>)。每种类型的Node定义了一系列附加属性，用于描述该特定类型。</p><p>有一些附加属性是每个Node上都有的，Babel生成了这些属性用于描述Node在源码中的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: ...,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">38</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">      line: <span class="number">3</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start</code>, <code>end</code>, <code>loc</code>,这些属性每个Node上都有。</p><h2 id="Babel的各个阶段"><a href="#Babel的各个阶段" class="headerlink" title="Babel的各个阶段"></a>Babel的各个阶段</h2><p>Babel的三个主要阶段是parse，transform，generate。</p><h3 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h3><p>Parse阶段接受代码输出AST。包括两个阶段： <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener"><strong>Lexical Analysis</strong></a> and <a href="https://en.wikipedia.org/wiki/Parsing" target="_blank" rel="noopener"><strong>Syntactic Analysis</strong></a></p><h4 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h4><p>词法分析将一串代码转换为tokens流。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * n;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"n"</span>, <span class="attr">start</span>: <span class="number">0</span>, <span class="attr">end</span>: <span class="number">1</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"*"</span>, <span class="attr">start</span>: <span class="number">2</span>, <span class="attr">end</span>: <span class="number">3</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">"n"</span>, <span class="attr">start</span>: <span class="number">4</span>, <span class="attr">end</span>: <span class="number">5</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里的每一个 <code>type</code>有一系列描述token的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ch <span class="keyword">of</span> the types here have a set <span class="keyword">of</span> properties describing the token:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &#123;</span><br><span class="line">    label: <span class="string">'name'</span>,</span><br><span class="line">    keyword: <span class="literal">undefined</span>,</span><br><span class="line">    beforeExpr: <span class="literal">false</span>,</span><br><span class="line">    startsExpr: <span class="literal">true</span>,</span><br><span class="line">    rightAssociative: <span class="literal">false</span>,</span><br><span class="line">    isLoop: <span class="literal">false</span>,</span><br><span class="line">    isAssign: <span class="literal">false</span>,</span><br><span class="line">    prefix: <span class="literal">false</span>,</span><br><span class="line">    postfix: <span class="literal">false</span>,</span><br><span class="line">    binop: <span class="literal">null</span>,</span><br><span class="line">    updateContext: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和AST中的Nodes一样也有<code>start</code>, <code>end</code>, and <code>loc</code>.</p><h4 id="Syntactic-Analysis"><a href="#Syntactic-Analysis" class="headerlink" title="Syntactic Analysis"></a>Syntactic Analysis</h4><p>语法分析将tokens流转换为AST。这个阶段利用tokens中的信息将它们重新格式化为AST，AST以一种更易于使用的方式来表示代码的结构。</p><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>Transform阶段接受AST并遍历它，在遍历的过程中增加、更新、删除节点。目前为止，这是Babel或者其他任何编译器中最复杂的阶段。这是插件操作的地方，并且是这本手册的主题。所以我们现在不会太深入。</p><h3 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h3><p>Generate阶段将AST转换为code，同时生成source maps。</p><h2 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h2><p>当你想转换AST时必须递归遍历树。</p><p>比如说 <code>FunctionDeclaration</code>这个类型。它有一些属性：<code>id</code>, <code>params</code>, and <code>body</code>。它们都有嵌套的节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"square"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  params: [&#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"n"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  body: &#123;</span><br><span class="line">    type: <span class="string">"BlockStatement"</span>,</span><br><span class="line">    body: [&#123;</span><br><span class="line">      type: <span class="string">"ReturnStatement"</span>,</span><br><span class="line">      argument: &#123;</span><br><span class="line">        type: <span class="string">"BinaryExpression"</span>,</span><br><span class="line">        operator: <span class="string">"*"</span>,</span><br><span class="line">        left: &#123;</span><br><span class="line">          type: <span class="string">"Identifier"</span>,</span><br><span class="line">          name: <span class="string">"n"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        right: &#123;</span><br><span class="line">          type: <span class="string">"Identifier"</span>,</span><br><span class="line">          name: <span class="string">"n"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Visitors"><a href="#Visitors" class="headerlink" title="Visitors"></a>Visitors</h3><p>当我们说”going”一个节点，实际上指的是访问它们。这里使用了<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener"><strong>visitor pattern</strong></a>.访问者模式在不同语言的AST遍历中都有使用。简而言之，Visitors是对象，这个对象中定义了接收树中特殊节点的方法。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  Identifier() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Called!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can also create a visitor and add methods on it later</span></span><br><span class="line"><span class="keyword">let</span> visitor = &#123;&#125;;</span><br><span class="line">visitor.MemberExpression = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">visitor.FunctionDeclaration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中， <code>Identifier()</code> 方法会被调用四次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.traverse(MyVisitor);</span><br><span class="line">Called!</span><br><span class="line">Called!</span><br><span class="line">Called!</span><br><span class="line">Called!</span><br></pre></td></tr></table></figure><p>以上是在进入node的时候被调用的，也可以在离开node时被调用。</p><p>有如下树形结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- FunctionDeclaration</span><br><span class="line">  - Identifier (id)</span><br><span class="line">  - Identifier (params[<span class="number">0</span>])</span><br><span class="line">  - BlockStatement (body)</span><br><span class="line">    - ReturnStatement (body)</span><br><span class="line">      - BinaryExpression (argument)</span><br><span class="line">        - Identifier (left)</span><br><span class="line">        - Identifier (right)</span><br></pre></td></tr></table></figure><p>遍历上面这棵树：</p><ul><li>Enter FunctionDeclaration<ul><li>Enter Identifier (id)<ul><li>Hit dead end</li></ul></li><li>Exit <code>Identifier (id)</code></li><li>Enter Identifier (params[0])<ul><li>Hit dead end</li></ul></li><li>Exit <code>Identifier (params[0])</code></li><li>Enter BlockStatement (body)<ul><li>Enter ReturnStatement (body)<ul><li>Enter BinaryExpression (argument)<ul><li>Enter Identifier (left)<ul><li>Hit dead end</li></ul></li><li>Exit <code>Identifier (left)</code></li><li>Enter Identifier (right)<ul><li>Hit dead end</li></ul></li><li>Exit <code>Identifier (right)</code></li></ul></li><li>Exit <code>BinaryExpression (argument)</code></li></ul></li><li>Exit <code>ReturnStatement (body)</code></li></ul></li><li>Exit <code>BlockStatement (body)</code></li></ul></li><li>Exit <code>FunctionDeclaration</code></li></ul><p>因此当创建一个visitor的时候有两次机会访问一个node。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  Identifier: &#123;</span><br><span class="line">    enter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Entered!"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    exit() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Exited!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>|</code> 或别名，同一个方法可以作用于多种类型的节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  <span class="string">"ExportNamedDeclaration|Flow"</span>(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Function</code>是<code>FunctionDeclaration</code>, <code>FunctionExpression</code>, <code>ArrowFunctionExpression</code>, <code>ObjectMethod</code> and <code>ClassMethod</code>的别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  <span class="built_in">Function</span>(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h3><p>AST中有许多Nodes，但是Nodes之间如何关联起来呢？我们可以使用Path，Path是一个呈现两个节点之间的关联的对象。</p><p>例如有如下节点和它的子节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"square"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的子节点<code>Identifier</code> 用path表示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"parent"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">    <span class="string">"id"</span>: &#123;...&#125;,</span><br><span class="line">    ....</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"node"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"square"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Path还有其他元数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"parent"</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">"node"</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">"hub"</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">"contexts"</span>: [],</span><br><span class="line">  <span class="string">"data"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"shouldSkip"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"shouldStop"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"removed"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"opts"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"skipKeys"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"parentPath"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"context"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"container"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"listKey"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"inList"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"parentKey"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"key"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"scope"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"type"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"typeAnnotation"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多新增、更新、移动、移除节点的方法，后续会讨论。</p><p>某种意义上，paths是一个节点在树中的位置及各种相关信息的响应式呈现。当你调用了一个方法修改了树，相关的信息会更新。Babel帮你管理这一切更新，从而让使用node变得更容易并且尽可能无状态。</p><h4 id="Paths-in-Visitors"><a href="#Paths-in-Visitors" class="headerlink" title="Paths in Visitors"></a>Paths in Visitors</h4><p>当你有一个<code>Identifier()</code>方法的visitor，你实际上是在访问path而不是node。</p><p>with the reactive representation of a node instead of the node itself.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyVisitor = &#123;</span><br><span class="line">  Identifier(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Visiting: "</span> + path.node.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b + c;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.traverse(MyVisitor);</span><br><span class="line">Visiting: a</span><br><span class="line">Visiting: b</span><br><span class="line">Visiting: c</span><br></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是AST转换的敌人。</p><p>例如如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function square(n) &#123;</span><br><span class="line">  return n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个重新命名的visitor，将 <code>n</code> 转换为 <code>x</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let paramName;</span><br><span class="line"></span><br><span class="line">const MyVisitor = &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    const param = path.node.params[0];</span><br><span class="line">    paramName = param.name;</span><br><span class="line">    param.name = &quot;x&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  Identifier(path) &#123;</span><br><span class="line">    if (path.node.name === paramName) &#123;</span><br><span class="line">      path.node.name = &quot;x&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这对上面的例子有效，但是对于下面的代码就不对了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function square(n) &#123;</span><br><span class="line">  return n * n;</span><br><span class="line">&#125;</span><br><span class="line">n;</span><br></pre></td></tr></table></figure><p>更好的处理方式是递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const updateParamNameVisitor = &#123;</span><br><span class="line">  Identifier(path) &#123;</span><br><span class="line">    if (path.node.name === this.paramName) &#123;</span><br><span class="line">      path.node.name = &quot;x&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const MyVisitor = &#123;</span><br><span class="line">  FunctionDeclaration(path) &#123;</span><br><span class="line">    const param = path.node.params[0];</span><br><span class="line">    const paramName = param.name;</span><br><span class="line">    param.name = &quot;x&quot;;</span><br><span class="line"></span><br><span class="line">    path.traverse(updateParamNameVisitor, &#123; paramName &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">path.traverse(MyVisitor);</span><br></pre></td></tr></table></figure><p>这个例子证明了如何消除全局状态。</p><h3 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h3><p>JavaScript 有 lexical scoping：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scope 1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// scope 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们转换代码时，需要小心作用域。我们需要确保修改代码的时候不会破坏已有的结构。</p><p>scope 可用如下形式表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: path,</span><br><span class="line">  block: path.node,</span><br><span class="line">  parentBlock: path.parent,</span><br><span class="line">  parent: parentScope,</span><br><span class="line">  bindings: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h4><p>引用都属于特定的作用域，这种关系称之为<code>bingding</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeOnce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ref = <span class="string">"This is a binding"</span>;</span><br><span class="line"></span><br><span class="line">  ref; <span class="comment">// This is a reference to a binding</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scopeTwo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ref; <span class="comment">// This is a reference to a binding from a lower scope</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>bingding</code>看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  identifier: node,</span><br><span class="line">  scope: scope,</span><br><span class="line">  path: path,</span><br><span class="line">  kind: &apos;var&apos;,</span><br><span class="line"></span><br><span class="line">  referenced: true,</span><br><span class="line">  references: 3,</span><br><span class="line">  referencePaths: [path, path, path],</span><br><span class="line"></span><br><span class="line">  constant: false,</span><br><span class="line">  constantViolations: [path]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Babel是一个多用途JavaScript编译器。不仅如此，它还是一系列用于不同形式静态分析的模块集合。&lt;/p&gt;
    
    </summary>
    
      <category term="technology" scheme="https://www.blocknews.xyz/categories/technology/"/>
    
    
      <category term="programming" scheme="https://www.blocknews.xyz/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Proxy与双向绑定</title>
    <link href="https://www.blocknews.xyz/2021/01/25/proxy%E4%B8%8E%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>https://www.blocknews.xyz/2021/01/25/proxy与双向绑定/</id>
    <published>2021-01-25T02:40:34.000Z</published>
    <updated>2021-02-01T04:06:24.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Proxy基础"><a href="#1-Proxy基础" class="headerlink" title="1 Proxy基础"></a>1 Proxy基础</h2><h3 id="1-1-创建Proxy"><a href="#1-1-创建Proxy" class="headerlink" title="1.1 创建Proxy"></a>1.1 创建Proxy</h3><blockquote><p>The <code>Proxy</code> object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.</p></blockquote><a id="more"></a><p>Proxy由两个参数创建：</p><ul><li>target：被代理的原始对象</li><li>handler：一个定义哪些操作会被拦截和重新定义的对象</li></ul><p>每个handler可以包含零个或多个捕获器,每个捕获器都对应一种基本操作,可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时,代理可以在这些操作传播到目标对象之前先调用捕获器函数,从而拦截并修改相应的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="string">"hehe"</span>,</span><br><span class="line">  b: <span class="string">"haha"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"proxied: "</span>+target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">target,prop,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">      target[prop]=value</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      target[prop] = <span class="string">"new prop"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.a) <span class="comment">//proxied: hehe</span></span><br><span class="line"></span><br><span class="line">proxy.b = <span class="number">123</span></span><br><span class="line">proxy.c =<span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"proxy"</span>,proxy) <span class="comment">//&#123; a: 'hehe', b: 123, c: 'new prop' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Reflect"><a href="#1-2-Reflect" class="headerlink" title="1.2 Reflect"></a>1.2 Reflect</h3><blockquote><p><strong>Reflect</strong> is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">proxy handlers</a>. <code>Reflect</code> is not a function object, so it’s not constructible.</p></blockquote><p>在Proxy中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="string">"hehe"</span>,</span><br><span class="line">  b: <span class="string">"haha"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy2.a)</span><br></pre></td></tr></table></figure><p>返回对象的own keys：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">  a: &quot;hehe&quot;,</span><br><span class="line">  b: &quot;haha&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Reflect.ownKeys(target);</span><br><span class="line">// [ &quot;a&quot;, &quot;b&quot; ]</span><br></pre></td></tr></table></figure><h3 id="1-3-可撤销代理"><a href="#1-3-可撤销代理" class="headerlink" title="1.3 可撤销代理"></a>1.3 可撤销代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> revocable = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"[["</span> + name + <span class="string">"]]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> proxy = revocable.proxy;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// "[[foo]]"</span></span><br><span class="line"></span><br><span class="line">revocable.revoke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// TypeError is thrown</span></span><br><span class="line">proxy.foo = <span class="number">1</span>           <span class="comment">// TypeError again</span></span><br><span class="line"><span class="keyword">delete</span> proxy.foo;       <span class="comment">// still TypeError</span></span><br><span class="line"><span class="keyword">typeof</span> proxy            <span class="comment">// "object", typeof doesn't trigger any trap</span></span><br></pre></td></tr></table></figure><h2 id="2-Proxy-应用"><a href="#2-Proxy-应用" class="headerlink" title="2 Proxy 应用"></a>2 Proxy 应用</h2><h3 id="2-1-双向绑定"><a href="#2-1-双向绑定" class="headerlink" title="2.1 双向绑定"></a>2.1 双向绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"price"</span>&gt;price:&lt;/label&gt;</span><br><span class="line">&lt;input id=<span class="string">"price"</span>  /&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"quantity"</span>&gt;quantity:&lt;/label&gt;</span><br><span class="line">&lt;input id=<span class="string">"quantity"</span>  /&gt;</span><br><span class="line"></span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"total"</span>&gt;total:&lt;/label&gt;</span><br><span class="line">&lt;input id=<span class="string">"total"</span> disabled /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> usedReactivities = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> effect = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  usedReactivities=[]</span><br><span class="line">  callback()</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [target,prop] <span class="keyword">of</span> usedReactivities)&#123;</span><br><span class="line">    track(target,prop,callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> track=<span class="function"><span class="keyword">function</span>(<span class="params">target,prop,effect</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!targetMap.has(target))&#123;</span><br><span class="line">    targetMap.set(target,<span class="keyword">new</span> <span class="built_in">Map</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!targetMap.get(target).has(prop))&#123;</span><br><span class="line">    targetMap.get(target).set(prop,<span class="keyword">new</span> <span class="built_in">Set</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = targetMap.get(target).get(prop);</span><br><span class="line">  deps.add(effect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> trigger=<span class="function"><span class="keyword">function</span>(<span class="params">target,prop</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!targetMap.has(target)||!targetMap.get(target).has(prop))&#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = targetMap.get(target).get(prop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> effect <span class="keyword">of</span> deps)&#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params">target,prop</span>)</span>&#123;</span><br><span class="line">    usedReactivities.push([target,prop])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,prop)</span><br><span class="line">  &#125;,</span><br><span class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">target,prop,value</span>)</span>&#123;</span><br><span class="line">    target[prop] =value</span><br><span class="line">  trigger(target,prop)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> product = &#123;</span><br><span class="line">  price:<span class="number">5</span>,</span><br><span class="line">  quantity:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxyProduct =<span class="keyword">new</span> <span class="built_in">Proxy</span>(product,handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> priceDom = <span class="built_in">document</span>.getElementById(<span class="string">"price"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> quantityDom = <span class="built_in">document</span>.getElementById(<span class="string">"quantity"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> totalDom = <span class="built_in">document</span>.getElementById(<span class="string">"total"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">priceDom.addEventListener(<span class="string">'input'</span>,event=&gt;&#123;</span><br><span class="line">  proxyProduct.price= event.target.value</span><br><span class="line">&#125;)</span><br><span class="line">quantityDom.addEventListener(<span class="string">'input'</span>,event=&gt;&#123;</span><br><span class="line">  proxyProduct.quantity= event.target.value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">effect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  priceDom.value=proxyProduct.price</span><br><span class="line">&#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  quantityDom.value=proxyProduct.quantity</span><br><span class="line">&#125;)</span><br><span class="line">effect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"effect callback start "</span>,total)</span><br><span class="line">  total = proxyProduct.price*proxyProduct.quantity</span><br><span class="line">  totalDom.value=total</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"effect callback end"</span>,total)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/silentzhou-the-sasster/pen/ExgBvbd" target="_blank" rel="noopener">codepen</a></p><h3 id="2-2-案例：调色板"><a href="#2-2-案例：调色板" class="headerlink" title="2.2 案例：调色板"></a>2.2 案例：调色板</h3><p><a href="https://codepen.io/silentzhou-the-sasster/pen/gOwNWbm" target="_blank" rel="noopener">codepen</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy-MDN</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming" target="_blank" rel="noopener">Meta programming-MDN</a></p><p><a href="https://v3.vuejs.org/guide/reactivity.html#what-is-reactivity" target="_blank" rel="noopener">Reactivity in Depth</a></p><p><a href="https://www.vuemastery.com/courses/vue-3-reactivity/vue3-reactivity/" target="_blank" rel="noopener">Vue3 Reactivity</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Proxy基础&quot;&gt;&lt;a href=&quot;#1-Proxy基础&quot; class=&quot;headerlink&quot; title=&quot;1 Proxy基础&quot;&gt;&lt;/a&gt;1 Proxy基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-创建Proxy&quot;&gt;&lt;a href=&quot;#1-1-创建Proxy&quot; class=&quot;headerlink&quot; title=&quot;1.1 创建Proxy&quot;&gt;&lt;/a&gt;1.1 创建Proxy&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;Proxy&lt;/code&gt; object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="technology" scheme="https://www.blocknews.xyz/categories/technology/"/>
    
    
      <category term="programming" scheme="https://www.blocknews.xyz/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Tree Shaking 学习笔记</title>
    <link href="https://www.blocknews.xyz/2021/01/19/Tree%20Shaking%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.blocknews.xyz/2021/01/19/Tree Shaking 学习笔记/</id>
    <published>2021-01-19T02:05:30.000Z</published>
    <updated>2021-02-01T09:29:30.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Tree-Shaking-必备理论"><a href="#1-Tree-Shaking-必备理论" class="headerlink" title="1. Tree Shaking 必备理论"></a>1. Tree Shaking 必备理论</h2><h3 id="1-1-Tree-Shaking-为什么要依赖ESM规范"><a href="#1-1-Tree-Shaking-为什么要依赖ESM规范" class="headerlink" title="1.1 Tree Shaking 为什么要依赖ESM规范"></a>1.1 Tree Shaking 为什么要依赖ESM规范</h3><a id="more"></a><p>ESM特点：</p><ul><li>import 模块名只能是字符串常量</li><li>import 一般只能在模块的最顶层出现</li><li>import binding 是immutable 的</li></ul><p>Tree Shaking 是在编译时进行无用代码消除，ESM具有静态分析能力。CommonJS只有在执行代码后才能动态确定依赖模块，不具备Tree Shaking的条件。</p><h3 id="1-2-sideEffects"><a href="#1-2-sideEffects" class="headerlink" title="1.2 sideEffects"></a>1.2 sideEffects</h3><blockquote><p>A “side effect” is defined as code that performs a special behavior when imported, other than exposing one or more exports. An example of this are polyfills, which affect the global scope and usually do not provide an export.</p></blockquote><p>具有副作用的模块难以被Tree Shaking 优化，Webpack 可以利用package.json 的side Effects属性来说明哪些模块具有副作用，剩余没有副作用的模块则可以被Tree Shaking优化.</p><p>“sideEffects”为false表示全部代码均无副作用，可以安全地删除未用到的export导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过数组表示，<code>./src/some-side-effectful-file.js</code>和所有<code>.css</code>文件模块都有副作用。对于 Webpack 工具，还可以在<strong><a href="https://github.com/webpack/webpack/issues/6065#issuecomment-351060570" target="_blank" rel="noopener">module.rule</a></strong>配置中声明副作用模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"./src/some-side-effectful-file.js"</span>，</span><br><span class="line">    <span class="string">"*.css"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Tree-Shaking-友好的导出模式"><a href="#2-Tree-Shaking-友好的导出模式" class="headerlink" title="2. Tree Shaking 友好的导出模式"></a>2. Tree Shaking 友好的导出模式</h2><h3 id="2-1-不友好的导出模式："><a href="#2-1-不友好的导出模式：" class="headerlink" title="2.1 不友好的导出模式："></a>2.1 不友好的导出模式：</h3><ul><li>导出一个包含多项属性和方法的对象</li><li>导出一个包含多项属性和方法的class</li><li>使用export default 导出</li></ul><p>Webpack 和Rollup通常只处理函数和顶层的import/export 变量，不能把没用到的类或对象内部的方法消除掉。即便有插件（例如webpack-deep-scope-plugin ）或新版本支持，都增加了不必要的成本。</p><h3 id="2-2-友好的导出模式："><a href="#2-2-友好的导出模式：" class="headerlink" title="2.2 友好的导出模式："></a>2.2 友好的导出模式：</h3><p>原子化和颗粒化导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-前端工程生态和-Tree-Shaking-实践"><a href="#3-前端工程生态和-Tree-Shaking-实践" class="headerlink" title="3. 前端工程生态和 Tree Shaking 实践"></a>3. 前端工程生态和 Tree Shaking 实践</h2><h3 id="3-1-Babel-和-Tree-Shaking"><a href="#3-1-Babel-和-Tree-Shaking" class="headerlink" title="3.1 Babel 和 Tree Shaking"></a>3.1 Babel 和 Tree Shaking</h3><p>Babel 默认会将 ESM 编译为 CommonJS ,需要更改Babel配置。但是如果不使用CommonJS，基于Node.js的Jest会有问题，解决办法是不同环境采用不同的Babel配置，prodution环境：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">production: &#123;</span><br><span class="line">   presets: [</span><br><span class="line">    [</span><br><span class="line">     <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">     &#123;</span><br><span class="line">      modules: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试环境中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test: &#123;</span><br><span class="line">   presets: [</span><br><span class="line">    [</span><br><span class="line">     <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">     &#123;</span><br><span class="line">      modules: <span class="string">'commonjs</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">   ]</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>但是一些第三方模块代码为了方便进行 Tree Shaking，暴露出符合 ESM 模块的代码，对于这些模块，比如 Library1、Library2，我们还需要进行处理，这时候需要配置 Jest：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> librariesToRecompile = [</span><br><span class="line"> <span class="string">'Library1'</span>,</span><br><span class="line"> <span class="string">'Library2'</span></span><br><span class="line">].join(<span class="string">'|'</span>)</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"> transformIgnorePatterns: [</span><br><span class="line">  <span class="string">`[\\/]node_modules[\\/](?!(<span class="subst">$&#123;librariesToRecompile&#125;</span>)).*$`</span></span><br><span class="line"> ],</span><br><span class="line"> transform: &#123;</span><br><span class="line">  <span class="string">'^.+\.jsx?$'</span>: path.resolve(__dirname, <span class="string">'transformer.js'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transformIgnorePatterns</code>是 Jest 的一个配置项，默认值为<code>node_modules</code>，它表示：<code>node_modules</code>中的第三方模块代码，都不需要经过<code>babel-jest</code>编译。因此，<strong>我们自定义 <code>transformIgnorePatterns</code>的值为一个包含了 Library1、Library2 的正则表达式即可</strong>。</p><h3 id="3-2-Webpack-和-Tree-Shaking"><a href="#3-2-Webpack-和-Tree-Shaking" class="headerlink" title="3.2 Webpack 和 Tree Shaking"></a>3.2 Webpack 和 Tree Shaking</h3><p><strong>Webpack4.0 以上版本在 mode 为 production 时，会自动开启 Tree Shaking 能力</strong>。</p><h2 id="4-如何设计一个兼顾Tree-Shaking-和易用性的公共库"><a href="#4-如何设计一个兼顾Tree-Shaking-和易用性的公共库" class="headerlink" title="4. 如何设计一个兼顾Tree Shaking 和易用性的公共库"></a>4. 如何设计一个兼顾Tree Shaking 和易用性的公共库</h2><p>在package.json中，mian字段暴露CommonJS 模块，module字段暴露ESM。当<code>require(&#39;Library&#39;)</code>时，Webpack 会找到：<code>dist/index.cjs.js</code>；当<code>import Library from &#39;Library&#39;</code>时，Webpack 会找到：<code>dist/index.esm.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Library"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"dist/index.cjs.js"</span>,</span><br><span class="line">  <span class="string">"module"</span>: <span class="string">"dist/index.esm.js"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-CSS-和Tree-Shaking"><a href="#5-CSS-和Tree-Shaking" class="headerlink" title="5. CSS 和Tree Shaking"></a>5. CSS 和Tree Shaking</h2><p><strong>CSS 的 Tree Shaking 要在样式表中，找出没有被应用到选择器样式，进行删除</strong>。<strong>可以通过 PostCSS 插件对 CSS 对应的 AST 进行操作，达到 Tree Shaking 的目的</strong>， <a href="https://github.com/FullHuman/purgecss/tree/master/packages/purgecss-webpack-plugin" target="_blank" rel="noopener">purgecss-webpack-plugin</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">Tree Shaking</a></p></li><li><p><a href="https://github.com/wuomzfx/tree-shaking-test" target="_blank" rel="noopener">《你的 Tree-Shaking 并没什么卵用》</a></p></li><li><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=584#/detail/pc?id=5916" target="_blank" rel="noopener">Tree Shaking：移除 JavaScript 上下文中的未引用代码</a></p></li><li><p><a href="https://www.jonathancreamer.com/webpack-tree-shaking-in-3-easy-steps/" target="_blank" rel="noopener">How I fixed webpack tree shaking in 3 easy steps</a></p></li><li><p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking" target="_blank" rel="noopener">Reduce JavaScript Payloads with Tree Shaking</a></p></li><li><p><a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">postcss</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Tree-Shaking-必备理论&quot;&gt;&lt;a href=&quot;#1-Tree-Shaking-必备理论&quot; class=&quot;headerlink&quot; title=&quot;1. Tree Shaking 必备理论&quot;&gt;&lt;/a&gt;1. Tree Shaking 必备理论&lt;/h2&gt;&lt;h3 id=&quot;1-1-Tree-Shaking-为什么要依赖ESM规范&quot;&gt;&lt;a href=&quot;#1-1-Tree-Shaking-为什么要依赖ESM规范&quot; class=&quot;headerlink&quot; title=&quot;1.1 Tree Shaking 为什么要依赖ESM规范&quot;&gt;&lt;/a&gt;1.1 Tree Shaking 为什么要依赖ESM规范&lt;/h3&gt;
    
    </summary>
    
      <category term="technology" scheme="https://www.blocknews.xyz/categories/technology/"/>
    
    
      <category term="programming" scheme="https://www.blocknews.xyz/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>[译]什么是promise?</title>
    <link href="https://www.blocknews.xyz/2019/02/04/%5B%E8%AF%91%5D%E4%BB%80%E4%B9%88%E6%98%AFpromise/"/>
    <id>https://www.blocknews.xyz/2019/02/04/[译]什么是promise/</id>
    <published>2019-02-04T03:58:39.000Z</published>
    <updated>2021-02-01T04:01:50.189Z</updated>
    
    <content type="html"><![CDATA[<p>Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。</p><a id="more"></a><blockquote><p>原文链接： <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261" target="_blank" rel="noopener">Master the JavaScript Interview: What is a Promise?</a><br>原文作者：<a href="https://medium.com/@_ericelliott/" target="_blank" rel="noopener">Eric Elliott</a><br>译者：SilentZhou</p></blockquote><p>Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。</p><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h2><p>Promises是立刻执行的，意味着promise的构造函数一旦被调用它会立刻开始执行任何你给的任务。如果你需要懒执行,可以看看<a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="noopener">observables</a> 或者<a href="https://github.com/rpominov/fun-task" target="_blank" rel="noopener">tasks</a>。</p><h2 id="一个不完整的Promises历史"><a href="#一个不完整的Promises历史" class="headerlink" title="一个不完整的Promises历史"></a>一个不完整的Promises历史</h2><p>Promises和futures(相似的概念)的早期实现于1980年代在MultiLisp和Concurrent Prolog这样的语言中出现的。“promise”这个词的使用最早是由 Barbara Liskov 和 Liuba Shrira 于1988年创造的。</p><p>我第一次在JavaScript中听说Promises的时候,Node还是一个全新的(事物),社区正在讨论处理异步行为的最佳方式。社区尝试过使用一段时间promises,但是最终选择了Node标准的错误优先回调。</p><p>与此同时,Dojo通过递延API添加了promises。(对promise的)兴趣和活动日益增长最终促使为了增加不同promise实现的互操作性的Promises/A规范的形成。</p><p>jQuery的异步操作基于promises进行了重构。jQuery的promise和Dojo的Deferred非常相似，由于jQuery一度非常流行它迅速成为最普遍使用的promise实现。然而，它不支持人们希望指望在其之上构建工具的两状态(执行态/拒绝态)链式调用和意外处理(<a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener">https://blog.domenic.me/youre-missing-the-point-of-promises/)。</a>。)</p><p>除了这些缺陷，jQuery正式让JavaScript promises成为主流，与此同时，更好的独立promise库例如Q和Bluebird变得非常流行。jQuery的promise实现的不兼容性激发了promise规范进行一些重要的澄清，promise因此被重写并被重新命名位<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a>。</p><p>ES6带来了兼容Promise/A+规范的全局Promise,其中一些非常重要的APIs建立在新标准Promise支持之上:特别是<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">WHATWG Fetch</a>规范和<a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">Async Functions</a>标准(写作此文时处于阶段3草案)。</p><p>这里描述的是兼容Promise/A+规范,专注于ECMAScript标准实现的promises。</p><h2 id="Promises是如何运行的"><a href="#Promises是如何运行的" class="headerlink" title="Promises是如何运行的"></a>Promises是如何运行的</h2><p>Promise是一个能够同步返回异步函数的对象。它可能处于这三种状态之一：</p><ol><li>执行态：onFulfilled()将会被调用(例如,resolve()被调用后)</li><li>拒绝态: onRejected())将会被调用(例如,reject()被调用后)</li><li>等待态: 还没有执行或拒绝</li></ol><p>Promise如果没有处于等待(已经resolved或者rejected)那么就解决了。有时候人们使用resolved和settled表示同一件事：没有处于等待。</p><p>一旦解决,promise不能重新被解决。再次调用<code>resolve()</code>和<code>reject()</code>不会有效果。解决后promise的不可变性是一个重要特征。</p><p>原生JavaScript的promise不会暴露promise状态。相反,你最好把promise当作一个黑盒子。只有负责创建promise的函数才了解promise的状态，并有解决和拒绝的权限。</p><p>这是一个返回了promise的函数，返回的promise将在固定时间的延迟后解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">time</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(resolve, time));</span><br><span class="line"></span><br><span class="line">wait(<span class="number">3000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>)); <span class="comment">// 'Hello!'</span></span><br></pre></td></tr></table></figure><p><code>wait(3000)</code>这个调用将在等待3000ms(3秒),然后打印<code>Hello!</code>。所有兼容规范的promise的都定义了一个<code>.then()</code>方法，该方法用于传递处理函数，处理函数可以接受解决值或拒绝值。</p><p>ES6的promise构造函数接受一个函数。该函数有两个参数，<code>resolve()</code>和<code>reject()</code>。在上面的例子中，我们只使用了<code>resolve()</code>，所以我们忽略了<code>reject()</code>。然后我们调用<code>setTimeout()</code>来形成延迟，然后当它结束时调用<code>resolve()</code>。</p><p>你可以将值传入<code>resolve()</code>或<code>reject()</code>，返回值将被传递到<code>.then()</code>方法的回调函数中。</p><p>当我使用<code>reject()</code>时，我总会传入一个Error对象。通常我希望有两种可能的解决状态：一种是正常的愉快之路，一种是例外——任何阻碍正常的愉快之路的情况。传入一个Error对象使情况更加明确。</p><h2 id="重要的Promise规则"><a href="#重要的Promise规则" class="headerlink" title="重要的Promise规则"></a>重要的Promise规则</h2><p>Promise标准是由<a href="https://promisesaplus.com/implementations" target="_blank" rel="noopener">Promises/A+</a>社区规范定义的。有许多遵照这个标准的实现，包括JavaScript标准的ECMAScript promises。</p><p>遵照规范的promises应该遵守一系列规则：</p><ol><li>promise或者thenable是一个提供了符合标准的<code>.then()</code>方法的对象。</li><li>等待态promise可以转变为执行或拒绝的状态。</li><li>一个执行态或拒绝态是已解决的，不能再转变为其它状态。</li><li>promise一旦解决，它必须有一个值(可以是<code>undefined</code>)。</li></ol><p>这是所说的改变是用<code>===</code>来比较的。完成值可以是对象，对象的属性允许改变。</p><p>每一个promise必须提供一个具有以下特征的<code>.then()</code>方法：</p><blockquote><p>promise.then(<br>onFulfilled?: Function,<br>onRejected?: Function<br>) =&gt; Promise</p></blockquote><p><code>.then()</code>方法必须遵照以下规则：</p><ol><li><code>onFulfilled()</code>和<code>onRejected()</code>都是可选参数。</li><li>如果提供的参数不是函数，则必须被忽略。</li><li><code>onFulfilled()</code>将会在promise被执行后调用，promise的值将作为第一个参数。</li><li><code>onRejected()</code>将会在promise被拒绝后调用，拒绝的理由将作为第一个参数。理由可以是任意的有效JavaScript值，但是因为拒绝本质上就是异常，我推荐使用Error对象。</li><li><code>onFulfilled()</code>和<code>onRejected()</code>都只能最多被调用一次。</li><li>同一个promise可能调用多次<code>.then()</code>。换言之，promise可以被用来汇总回调函数。</li><li><code>.then()</code>方法必须返回一个新的promise:<code>promise2</code>。</li><li>如果<code>onFulfilled()</code>或<code>onRejected()</code>有一个返回值<code>x</code>，并且<code>x</code>是一个promise，promise2将锁定为<code>x</code>(假定与<code>x</code>有相同的状态和值)。否则,promise2将被执行且值是<code>x</code>。</li><li>如果<code>onFulfilled()</code>或<code>onRejected()</code>抛出一个异常<code>e</code>,promise2必须以<code>e</code>作为理由被拒绝。</li><li>如果<code>onFulfilled()</code>不是一个函数并且promise1已经被执行，promise2则必须以同promise1相同的值被执行。</li><li>如果<code>onRejected()</code>不是一个函数并且promise1已经被拒绝，promise2则必须以同promise1相同的理由被拒绝。</li></ol><h2 id="Promise链"><a href="#Promise链" class="headerlink" title="Promise链"></a>Promise链</h2><p>因为<code>.then()</code>总是返回一个新的promise，那么精确控制如何处理和在什么地方处理错误链式调用Promise。Promises允许你模仿同步代码的<code>try/catch</code>行为。</p><p>和同步代码一样，链式调用会形成顺序执行。换言之，你可以这样做：</p><blockquote><p>fetch(url)<br>.then(process)<br>.then(save)<br>.catch(handleErrors)<br>;</p></blockquote><p>假设每一个函数,<code>fetch()</code>,<code>process()</code>,和<code>save()</code>都返回promises, <code>process()</code>将等待<code>fetch()</code>完成再开始,<code>save()</code>将等待<code>process()</code>完成再开始。<code>handleErrors()</code>只会当前面任意一个promise拒绝时才执行。</p><p>这是一个多次拒绝的复杂promise链的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">time</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  res =&gt; setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> res(), time)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wait(<span class="number">200</span>)</span><br><span class="line">  <span class="comment">// onFulfilled() can return a new promise, `x`</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> res(<span class="string">'foo'</span>)))</span><br><span class="line">  <span class="comment">// the next promise will assume the state of `x`</span></span><br><span class="line">  .then(<span class="function"><span class="params">a</span> =&gt;</span> a)</span><br><span class="line">  <span class="comment">// Above we returned the unwrapped value of `x`</span></span><br><span class="line">  <span class="comment">// so `.then()` above returns a fulfilled promise</span></span><br><span class="line">  <span class="comment">// with that value:</span></span><br><span class="line">  .then(<span class="function"><span class="params">b</span> =&gt;</span> <span class="built_in">console</span>.log(b)) <span class="comment">// 'foo'</span></span><br><span class="line">  <span class="comment">// Note that `null` is a valid promise value:</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">null</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">c</span> =&gt;</span> <span class="built_in">console</span>.log(c)) <span class="comment">// null</span></span><br><span class="line">  <span class="comment">// The following error is not reported yet:</span></span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'foo'</span>);&#125;)</span><br><span class="line">  <span class="comment">// Instead, the returned promise is rejected</span></span><br><span class="line">  <span class="comment">// with the error as the reason:</span></span><br><span class="line">  .then(</span><br><span class="line">    <span class="comment">// Nothing is logged here due to the error above:</span></span><br><span class="line">    d =&gt; <span class="built_in">console</span>.log(<span class="string">`d: <span class="subst">$&#123; d &#125;</span>`</span>),</span><br><span class="line">    <span class="comment">// Now we handle the error (rejection reason)</span></span><br><span class="line">    e =&gt; <span class="built_in">console</span>.log(e)) <span class="comment">// [Error: foo]</span></span><br><span class="line">  <span class="comment">// With the previous exception handled, we can continue:</span></span><br><span class="line">  .then(<span class="function"><span class="params">f</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`f: <span class="subst">$&#123; f &#125;</span>`</span>)) <span class="comment">// f: undefined</span></span><br><span class="line">  <span class="comment">// The following doesn't log. e was already handled,</span></span><br><span class="line">  <span class="comment">// so this handler doesn't get called:</span></span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'bar'</span>); &#125;)</span><br><span class="line">  <span class="comment">// When a promise is rejected, success handlers get skipped.</span></span><br><span class="line">  <span class="comment">// Nothing logs here because of the 'bar' exception:</span></span><br><span class="line">  .then(<span class="function"><span class="params">g</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`g: <span class="subst">$&#123; g &#125;</span>`</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">h</span> =&gt;</span> <span class="built_in">console</span>.log(h)) <span class="comment">// [Error: bar]</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>请注意promises同时具有成功和错误处理函数，很容易见到下面这样的代码：</p><blockquote><p>save().then(<br>handleSuccess,<br>handleError<br>);</p></blockquote><p>但是如果<code>handleSuccess()</code>抛出了错误该怎么办?从<code>.then()</code>返回的promise会被拒绝，但是没办法捕捉到这个拒绝——意味着一个错误在你的app中被吞没了。天哪！</p><p>因为这个原因，一些人认为上面的代码是反模式的，并且推荐下面的写法：</p><blockquote><p>save()<br>.then(handleSuccess)<br>.catch(handleError)<br>;</p></blockquote><p>其中的区别是微妙但重要的。在第一个例子中，源自<code>save()</code>操作的错误将被捕获，但是源自<code>handleSuccess()</code>函数的错误将被吞没。</p><p>在第二个例子中，<code>.catch()</code>将会处理来自<code>save()</code>或<code>handleSuccess()</code>的拒绝。</p><p>当然，<code>save()</code>错误可能是网络错误，而<code>handleSuccess()</code>错误可能是因为开发者忘记处理特定的状态码。如果你想以不同方式处理他们呢?你可以选择同时处理他们：</p><blockquote><p>save()<br>.then(<br>handleSuccess,<br>handleNetworkError<br>) .catch(handleProgrammerError)<br>;</p></blockquote><p>无论你喜欢哪种方式，我建议在所有promise链的末尾加上<code>.catch()</code>。值得重复一遍：</p><blockquote><p>我建议在所有promise链的末尾加上<code>.catch()</code>。</p></blockquote><h2 id="我如何取消一个promise？"><a href="#我如何取消一个promise？" class="headerlink" title="我如何取消一个promise？"></a>我如何取消一个promise？</h2><p>Promise的新用户经常想知道的第一件事是如何取消一个promise。这有个主意：只需要以<code>取消</code>为理由拒绝这个promise。如果你需要以不同于寻常错误的方式来处理它，那么你可以在你的错误处理程序中新建一个分支。</p><p>这里是一些人们取消promise时犯的常见错误：</p><h3 id="在promise上添加-cancel"><a href="#在promise上添加-cancel" class="headerlink" title="在promise上添加.cancel()"></a>在promise上添加.cancel()</h3><p>添加<code>.cancel()</code>让promise变得不合标准，而且同时也打破了另一条promise的规则：只有创建promise的函数才能够解决，拒绝，取消promise。暴露它破坏了封装性，并且鼓励人们在他们不应该知道的地方编写操作promise的代码。应该避免面条代码和破坏promise。</p><h3 id="忘记清除"><a href="#忘记清除" class="headerlink" title="忘记清除"></a>忘记清除</h3><p>一些聪明人已经明白有办法利用<code>Promise.race()</code>作为取消机制。这里的问题是取消控制在创建promise的函数中进行，这个函数是唯一可以进行适当清理活动的地方，例如清除超时或者通过清除对数据的引用来释放内存，等等…</p><h3 id="忘记处理被拒绝的取消promise"><a href="#忘记处理被拒绝的取消promise" class="headerlink" title="忘记处理被拒绝的取消promise"></a>忘记处理被拒绝的取消promise</h3><p>你知道当你忘记处理被拒绝的promise时Chrome会一直在控制台发出警告消息吗？天哪！</p><h3 id="过于复杂"><a href="#过于复杂" class="headerlink" title="过于复杂"></a>过于复杂</h3><p>撤销的TC39提案提出了一个单独的消息通道用于取消。它使用了一个称作取消令牌的新概念。在我看来，这个方案会让promise规范变得相当臃肿。它提供的原有规范不支持的唯一特征是<code>拒绝</code>和<code>取消</code>的分离，但在我看来，这是一开始就没必要的。</p><p>你想根据是否有异常或取消来切换处理方式吗？是的，当然。但这是promise的工作吗？在我看来,不，它不是。</p><h3 id="重新思考promise的取消"><a href="#重新思考promise的取消" class="headerlink" title="重新思考promise的取消"></a>重新思考promise的取消</h3><p>通常，我会在promise创建时传入所有promise决定如何解决/拒绝/取消所需要的信息。那样的话，promise不需要一个<code>.cancel()</code>方法。你可能奇怪如何在promise创建时就知道是否需要取消。</p><blockquote><p>“如果我不确定是否要取消，我怎么知道在promise创建时传入什么？”</p></blockquote><p>如果存在一种对象可以代表未来的一个值… oh，等等。</p><p>我们传入的代表是否取消的值自身也可以是一个promise。它看起来可能是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = (</span><br><span class="line">  time,</span><br><span class="line">  cancel = <span class="built_in">Promise</span>.reject()</span><br><span class="line">) =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setTimeout(resolve, time);</span><br><span class="line">  <span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  cancel.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cancelled'</span>));</span><br><span class="line">  &#125;, noop);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shouldCancel = <span class="built_in">Promise</span>.resolve(); <span class="comment">// Yes, cancel</span></span><br><span class="line"><span class="comment">// const shouldCancel = Promise.reject(); // No cancel</span></span><br><span class="line"></span><br><span class="line">wait(<span class="number">2000</span>, shouldCancel).then(</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>),</span><br><span class="line">  (e) =&gt; <span class="built_in">console</span>.log(e) <span class="comment">// [Error: Cancelled]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们使用默认参数使它默认不取消。它使<code>cancel</code>参数变成方便的可选参数。然后我们像之前一样设置超时，但是这次我们保存了超时计时的ID以便之后清除。</p><p>我们使用<code>cancel.then()</code>方法来处理取消和资源清理。这个方法只会在promise有机会解决之前被取消时才会运行。如果你取消得太晚，你会错过机会。火车已经驶离站台了。</p><blockquote><p>注意：你可能想知道<code>noop()</code>函数是干什么的。<code>noop</code>这个词的意思是空操作，意味着函数什么也不做。如果没有它，V8会抛出警告消息：<code>UnhandledPromiseRejectionWarning: Unhandled promise rejection</code>。始终处理promise拒绝是一个好主意，即使处理函数是一个<code>noop()</code>。</p></blockquote><h3 id="概括promise的取消"><a href="#概括promise的取消" class="headerlink" title="概括promise的取消"></a>概括promise的取消</h3><p>这对于<code>wait()</code>计时器是很好的，但我们还可以进一步抽象出来封装所有你不得不记住的事：</p><ol><li><code>cancel promise</code>的默认状态为拒绝——如果没有传入<code>cancel promise</code>，我们不想取消或出现错误。</li><li>当你拒绝取消时请记得执行清理。</li><li>请记住，<code>onCancel</code>清理时自身可能会产生错误，这个错误也需要处理。(请注意在上面的等待例子中错误处理被省略了——它很容易被忘记!)</li></ol><p>让我们创建一个可以取消promise的基础工具，它可以用来包裹任何promise。例如，处理网络申请，等等…它看起来像这样：</p><blockquote><p>speculation(fn: SpecFunction, shouldCancel: Promise) =&gt; Promise</p></blockquote><p><code>SpecFunction</code>就像你传入<code>Promise</code>构造函数的函数一样，只有一点不同——它有一个<code>onCancel()</code>处理函数：</p><blockquote><p>SpecFunction(resolve: Function, reject: Function, onCancel: Function) =&gt; Void</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOF Wraps the native Promise API</span></span><br><span class="line"><span class="comment">// to add take a shouldCancel promise and add</span></span><br><span class="line"><span class="comment">// an onCancel() callback.</span></span><br><span class="line"><span class="keyword">const</span> speculation = (</span><br><span class="line">  fn,</span><br><span class="line">  cancel = <span class="built_in">Promise</span>.reject() <span class="comment">// Don't cancel by default</span></span><br><span class="line">) =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> noop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onCancel = (</span><br><span class="line">    handleCancel</span><br><span class="line">  ) =&gt; cancel.then(</span><br><span class="line">      handleCancel,</span><br><span class="line">      <span class="comment">// Ignore expected cancel rejections:</span></span><br><span class="line">      noop</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle onCancel errors</span></span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> reject(e))</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  fn(resolve, reject, onCancel);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>请注意，这只是一个告诉你它工作原理的要点的例子。你还需要考虑许多其它边缘情况。<br>例如，在这个例子中，如果你在promise已经解决后取消promise，<code>handleCancel</code>将会被调用。</p><p>我将这些边缘情况实现了一个在维护的生产版本作为开源库，<a href="https://github.com/ericelliott/speculation" target="_blank" rel="noopener">Speculation</a>。</p><p>让我们使用改进的库来重写可取消的<code>wait()</code>程序。首先安装speculation：</p><blockquote><p>npm install –save speculation</p></blockquote><p>现在你可以引入并使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> speculation <span class="keyword">from</span> <span class="string">'speculation'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wait = (</span><br><span class="line">  time,</span><br><span class="line">  cancel = <span class="built_in">Promise</span>.reject() <span class="comment">// By default, don't cancel</span></span><br><span class="line">) =&gt; speculation(<span class="function">(<span class="params">resolve, reject, onCancel</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = setTimeout(resolve, time);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use onCancel to clean up any lingering resources</span></span><br><span class="line">  <span class="comment">// and then call reject(). You can pass a custom reason.</span></span><br><span class="line">  onCancel(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cancelled'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, cancel); <span class="comment">// remember to pass in cancel!</span></span><br><span class="line"></span><br><span class="line">wait(<span class="number">200</span>, wait(<span class="number">500</span>)).then(</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>),</span><br><span class="line">  (e) =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">); <span class="comment">// 'Hello!'</span></span><br><span class="line"></span><br><span class="line">wait(<span class="number">200</span>, wait(<span class="number">50</span>)).then(</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>),</span><br><span class="line">  (e) =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">); <span class="comment">// [Error: Cancelled]</span></span><br></pre></td></tr></table></figure><p>这样就简化了许多，因为你不需要担心<code>noop()</code>,在<code>onCancel()</code>中捕捉错误或者其它边缘情况。那些细节已经被<code>speculation()</code>提取出来了。看看这个，在真实项目中自由使用它吧。</p><h2 id="原生JS-Promise的额外内容"><a href="#原生JS-Promise的额外内容" class="headerlink" title="原生JS Promise的额外内容"></a>原生JS Promise的额外内容</h2><p>原生Promise对象有一些你可能感兴趣的其它内容：</p><ul><li><code>Promise.reject()</code>返回一个被拒绝的promise。</li><li><code>Promise.resolve()</code>返回一个被解决的promise。</li><li><code>Promise.race()</code>接受一个数组(或任何可迭代对象)，返回一个promise，这个promise将会在第一个解决promise之后以相同的值解决，或者在第一个拒绝的promise之后以相同的理由拒绝。</li><li><code>Promise.all()</code>接受一个数组(或任何可迭代对象)，返回一个promise，这个promise将会在所有可迭代参数的promises解决之后解决，或者在第一个拒绝的promise之后以相同的理由拒绝。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Promises已经变成JavaScript中几个习惯用法的一部分，包括用于现代ajax请求的<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">WHATWG Fetch</a>标准，和用于让异步代码看起来像同步代码的<a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">Async Functions</a>标准。</p><p>写这篇文章的时候<code>Async functions</code>处于第3阶段，但是我预计它们会很快变成JavaScript中一个流行的，常用的异步编程解决方案——意味着对于JavaScript开发者，学习领会promises将在不远的将来变得更加重要。</p><p>例如，如果你正在使用Redux,我建议你看看<a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a>:一个用于管理Redux中副作用的库,纵观文档它依赖于<code>async functions</code>。</p><p>我希望即使是有经验的promise使用者在阅读完本文后，对于什么是promise、promise的工作原理以及如何更好地使用promise能够有更好的了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise是一个可能会在未来某个时刻产生一个值的对象：一个解决值或者是没有解决的理由(例如网络错误)。Promise可能处于以下3种状态的一种：执行态，拒绝态，等待态。Promise使用者可以添加回调函数来处理返回值或者被拒绝的理由。&lt;/p&gt;
    
    </summary>
    
      <category term="technology" scheme="https://www.blocknews.xyz/categories/technology/"/>
    
    
      <category term="programming" scheme="https://www.blocknews.xyz/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>[译]什么是纯函数?</title>
    <link href="https://www.blocknews.xyz/2019/01/23/%E8%AF%91-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>https://www.blocknews.xyz/2019/01/23/译-什么是纯函数/</id>
    <published>2019-01-23T01:56:37.000Z</published>
    <updated>2019-01-23T09:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？</p><a id="more"></a><blockquote><p>原文链接： <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" target="_blank" rel="noopener">Master the JavaScript Interview: What is a Pure Function?</a><br>原文作者：<a href="https://medium.com/@_ericelliott/" target="_blank" rel="noopener">Eric Elliott</a><br>译者：<a href="https://github.com/SilentZhou" target="_blank" rel="noopener">SilentZhou</a></p></blockquote><p>纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？</p><p>通过一个免费课程 <a href="http://ericelliottjs.com/product/lifetime-access-pass/" target="_blank" rel="noopener">“Learn JavaScript with Eric Elliott”</a>:我们能够回答这个问题。</p><p>在我们掌握什么是纯函数之前,让我们先仔细看看什么是函数。或许有一种让函数式编程更容易理解的方式来看待函数。</p><h2 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h2><p>函数是一个获取输入,调用参数,输出返回值的过程。函数有以下用途：</p><ol><li>映射：基于输入产生输出。函数使输入和输出之间产生映射关系。</li><li>程序：函数被调用以执行一系列步骤。执行顺序被称为过程,这种编程方式被称为过程程序设计。</li><li>I/O:一些函数被用于与系统的其它部分通信,例如屏幕,存储,系统日志或者网络。</li></ol><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>纯函数都是映射。函数映射输入参数为返回值,意味着对于每一组输入,都有一个输出值。函数会获取输入然后返回相关的输出。</p><p>`Math.max()`以数字为参数返回其中最大值：</p><pre><code>Math.max(2, 8, 5); // 8</code></pre><p>在这个例子中,2、8和5是参数。它们是被传入函数的值。</p><p>`Math.max()`是一个传入任意个数字然后返回其中最大值的函数。在这里,我们传入的最大数字是8,这就是返回的数字。</p><p>函数在计算和数学中真的非常重要。它们帮助我们以有用的方式处理数据。好的程序员会给函数一个描述性的函数名,当我们看代码的时候可以看函数名就可以了解这个函数是做什么的。</p><p>数学中也有函数,而且运行方式和javascript中的函数非常相似。你很可能在代数中见过函数。它们就像下面这样：</p><p>f(x) = 2x</p><p>这意味着我们正在声明一个名为f的函数,这个函数接收一个参数x,然后将x乘以2.</p><p>要使用这个函数,我们只需要为x提过一个值：</p><p>f(2)</p><p>在代数中,这个和下面写的是相同的：</p><p>4</p><p>因此你可以在任何地方将f(2)替换成4.</p><p>现在让我们将这个函数转换为javascript:</p><pre><code>const double = x =&gt; x * 2;</code></pre><p>你可以用`console.log()`检查这个函数的输出：</p><pre><code>console.log( double(5) ); // 10</code></pre><p>还记得我说过在数学函数中你可以用4替换f(2)吗？在这里,javascript引擎将double(5)替换成答案10.</p><p>因此, `console.log( double(5) );`和`console.log(10);`是一样的。</p><p>这是正确的，因为`double()`是一个纯函数，但是如果`double()`有副作用，例如存储值到硬盘或者记录到控制台，你没办法只替换`double(5)` 为10而不改变原函数的意义。</p><p>如果你想要引用透明性（referential transparency），你需要使用纯函数。</p><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>一个纯函数是一个这样的函数：</p><ul><li>相同的输入，总会返回相同的输出。</li><li>不会产生副作用。</li></ul><p>如果一个函数被调用时没有用到返回值也是有意义的，那绝对是一个不纯的函数。对于纯函数，那就是一个空语句。</p><p>我建议你偏爱纯函数。意思是，如果用纯函数实现一个程序需求是可行的，那就用纯函数而不是其他选项。纯函数获得一些输入然后重要的设计原则是KISS (Keep It Simple, Stupid).我喜欢让它愚蠢的简单。纯函数用最可行的方式保持愚蠢的简单。</p><p>纯函数有很多有益的属性，这些属性形成了函数式编程的基础。纯函数完全独立于外部状态，因此纯函数可以免于由于共享可变状态造成的漏洞。纯函数的独立性使它成为多cpu和分布式计算集群中并发编程的不错选择，使他们成为很多类型的科学和资源密集型计算任务的必要部分。</p><p>纯函数也非常独立-易于在代码中移动，重构和重新组织，使你的程序更灵活，能够适应未来的变化。</p><h2 id="共享状态的麻烦"><a href="#共享状态的麻烦" class="headerlink" title="共享状态的麻烦"></a>共享状态的麻烦</h2><p>几年前我正在做一个能够让用户搜索音乐家然后加载这个音乐家的音乐列表到web播放器上的app。当时Google Instant刚刚推出，它会在您输入搜索查询时显示即时搜索结果。基于Ajax的自动补全突然风行一时。</p><p>唯一的问题是用户输入经常比自动补全搜索响应快，这会造成一些奇怪的错误。它会触发竞态条件，更新的建议会被过时的建议替换掉。</p><p>为什么会发生这种情况？ AJAX成功时的处理函数能够直接更新用户看到的列表。最慢的AJAX请求总是能通过盲目替换结果来赢得用户的注意，甚至会替换掉更新的结果。</p><p>任何种类的异步操作或并发会造成相似的竞态条件。竞态条件会在输出依赖于不受控事件（例如网络、设备延迟、用户输入、随机性等等）的顺序时发生。事实上，如果你使用共享状态而状态依赖于根据不确定性因素而变化的顺序时，总而言之，输出无法预测，也就意味着不可能进行适当的测试或完全理解。正如Martin Odersky所说：</p><blockquote><p>非确定性  =  并行处理 + 共享状态</p></blockquote><p>程序确定性通常是计算中一个理想的特性。或许你觉得这不是问题因为javascript是单线程，因此不会有并行处理问题，但是正如AJAX这个例子说明的，一个单线程js引擎并不意味着没有并发。事实正相反，JavaScript中有很多种并发。API I/O, event listeners, web workers, iframes, and timeouts都会给你的程序带来不可预测性。把它们和共享状态结合，你就得到了很多的错误。</p><p>纯函数可以帮你避免这类错误。</p><h2 id="给定相同的输入，始终返回相同的输出"><a href="#给定相同的输入，始终返回相同的输出" class="headerlink" title="给定相同的输入，始终返回相同的输出"></a>给定相同的输入，始终返回相同的输出</h2><p>使用`double()`函数时，你可以用结果替换函数调用，程序是相同的 — 在你的程序中`double(5)`和 `10` 意味着同一件事，无论上下文如何、无论何时调用、无论调用多少次。</p><p>但是你不能说所有的函数都是如此。一些函数不仅仅依赖传入的参数来产生输出。</p><p>想一想下面这个例子：</p><pre><code>Math.random(); // =&gt; 0.4011148700956255Math.random(); // =&gt; 0.8533405303023756Math.random(); // =&gt; 0.3550692005082965</code></pre><p>即使我们没有传入任何值到函数中，它们都产生了不同的输出，意味着`Math.random()`不是纯的。</p><p>`Math.random()`每次运行时会产生一个新的介于0到1之间的随机值，因此很明显你不能用0.4011148700956255替换掉它而不使程序的含义发生变化。</p><p>那样每次就会产生相同的结果。我们每次向计算机请求一个随机数的时候，通常意味着我们想得到一个不同于上一次的结果。如果一对骰子的每一面都印着相同的数字，那还有什么意义呢？</p><p>有时候我们会向计算机询问现在的时间。我们不会深究这个函数的实现细节。现在，复制下面的代码：</p><pre><code>const time = () =&gt; new Date().toLocaleTimeString();time(); // =&gt; &quot;5:15:45 PM&quot;</code></pre><p>如果你用现在的时间替换掉`time()`会发生什么？</p><p>它会说是总是相同的时间：这个函数被替换的时间。换言之，它一天只能产生一次正确的输出，只有当你在这个函数被替换的精确时刻运行这个程序才行。</p><p>很清楚，`time()`函数不像`double()` 函数。</p><p>一个函数只有当给定相同的输入产生相同的输出时才是纯函数。你可能记得这条从代数课上学到的规则：相同的输入值总是映射到相同的输出值。然而，许多输入值可能映射到相同的输出值。例如，下面的函数时纯函数：</p><pre><code>const highpass = (cutoff, value) =&gt; value &gt;= cutoff;</code></pre><p>相同的输入值总是会映射到相同的输出值：</p><pre><code>highpass(5, 5); // =&gt; truehighpass(5, 5); // =&gt; truehighpass(5, 5); // =&gt; true</code></pre><p>许多输入值总是会映射到相同的输出值：</p><pre><code>highpass(5, 123); // truehighpass(5, 6);   // truehighpass(5, 18);  // truehighpass(5, 1);   // falsehighpass(5, 3);   // falsehighpass(5, 4);   // false</code></pre><p>一个纯函数必须不依赖任何外部可变状态，因为那样的话它将不再具有确定性和引用透明性。</p><h2 id="纯函数不产生副作用"><a href="#纯函数不产生副作用" class="headerlink" title="纯函数不产生副作用"></a>纯函数不产生副作用</h2><p>一个纯函数不产生任何副作用，意味着它不能改变任何外部状态。</p><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>JavaScript的对象参数是引用传递，意味着如果一个函数修改了对象或数组参数的属性,这将改变在函数外部可访问的状态。</p><p>相想下面这个改变，不纯的`addToCart()`函数:</p><pre><code>// impure addToCart mutates existing cartconst addToCart = (cart, item, quantity) =&gt; {    cart.items.push({    item,    quantity    });    return cart;};test(&apos;addToCart()&apos;, assert =&gt; {    const msg = &apos;addToCart() should add a new item to the cart.&apos;;    const originalCart =     {    items: []    };    const cart = addToCart(    originalCart,    {        name: &quot;Digital SLR Camera&quot;,        price: &apos;1495&apos;    },    1    );    const expected = 1; // num items in cart    const actual = cart.items.length;    assert.equal(actual, expected, msg);    assert.deepEqual(originalCart, cart, &apos;mutates original cart.&apos;);    assert.end();});</code></pre><p>这个函数传入了一个购物车，一个被放入购物车的项目和项目数量，然后返回了项目被添加后的同一个购物车。</p><p>问题是我们修改了一些共享状态。在这个函数被调用之前，其它函数也许依赖于那个购物车对象的状态，现在我们既然修改了那个共享状态，如果我们改变函数的调用顺序就不得不担心会对程序逻辑造成什么影响。重构代码可能会导致出现错误，这会搞砸订单引起顾客的不满。</p><p>现在考虑下面这个版本：</p><pre><code>// Pure addToCart() returns a new cart// It does not mutate the original.const addToCart = (cart, item, quantity) =&gt; {const newCart = lodash.cloneDeep(cart);newCart.items.push({    item,    quantity});return newCart;};test(&apos;addToCart()&apos;, assert =&gt; {const msg = &apos;addToCart() should add a new item to the cart.&apos;;const originalCart = {    items: []};// deep-freeze on npm// throws an error if original is mutateddeepFreeze(originalCart);const cart = addToCart(    originalCart,    {    name: &quot;Digital SLR Camera&quot;,    price: &apos;1495&apos;    },    1);const expected = 1; // num items in cartconst actual = cart.items.length;assert.equal(actual, expected, msg);assert.notDeepEqual(originalCart, cart,    &apos;should not mutate original cart.&apos;);assert.end();});</code></pre><p>在这个例子中，有一个嵌套在对象中的数组，这也是为什么我使用了深拷贝。这是一个比你通常要处理的状态更复杂的状态。对于大多数情况，你可以将它分成更小的块。</p><p>例如，Redux让你组合reducers而不是在每个reducer中处理整个应用的状态。结果就是当你每次更新状态中的一小部分时，你不必深拷贝整个应用状态。相反，你可以使用非破坏性的数组方法或者`Object.assign()`来更新应用状态的一小部分。</p><p>轮到你了，修改<a href="https://codepen.io/ericelliott/pen/MyojLq?editors=0010" target="_blank" rel="noopener">“这个非纯函数”</a>为纯函数。使它在不修改测试代码的情况下通过单元测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纯函数是函数式编程、可靠并发、React+Redux应用等必不可少的一部分。但是纯函数究竟是什么意思呢？&lt;/p&gt;
    
    </summary>
    
      <category term="technology" scheme="https://www.blocknews.xyz/categories/technology/"/>
    
    
      <category term="programming" scheme="https://www.blocknews.xyz/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>我们还要再等30年吗?</title>
    <link href="https://www.blocknews.xyz/2018/09/25/%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E5%86%8D%E7%AD%8930%E5%B9%B4%E5%90%97/"/>
    <id>https://www.blocknews.xyz/2018/09/25/我们还要再等30年吗/</id>
    <published>2018-09-25T07:18:00.000Z</published>
    <updated>2019-01-23T09:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>我是一个假乐迷。去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。</p><a id="more"></a><p>我是一个假乐迷。</p><p>去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。然而，即使是他们的歌，我也谈不上非常熟悉。我勉强挤在外围，不敢太靠近舞台，靠近舞台的是一听前奏就开始摇头晃脑跟着哼唱的核心歌迷。其实我不常听歌，唱歌五音不全，喜欢他们的歌因为歌中表达的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一个假乐迷。去看仙人掌音乐节是因为有崔健、万能青年旅店和李志。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://www.blocknews.xyz/categories/life/"/>
    
    
      <category term="music" scheme="https://www.blocknews.xyz/tags/music/"/>
    
  </entry>
  
</feed>
